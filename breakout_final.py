# -*- coding: utf-8 -*-
"""Breakout_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oY7vJpzvGDnjReA4eE6sInUt0XKkt2nw

# **shadi awidat - 322289232**
# **noor abu elfool - 206692170**

the outputs are what we get in our last run, the colab crashed in episode 32395, we saved a copy of our model in the drive every 1000 episode, we used the last one in order to make the vedio in the last cell.
we worked with gpu t4.
the vedio is in the last cell, we succeeded a vedio with time-length 41 seconds


the plots that showing the rewards in the training process are in the cell before the vedio we printed each episode the reward we got.

in the same cell we plotted a graph showing the reward we get each episode every 1000 episode.

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfYAAAGWCAYAAACKH6HmAAAgAElEQVR4AeydB3gVVd7/fXd11y3P7uuz7+76vru6imLHunZFkRUbYgEbRawIqCgWmiBNOoJSRQERkCJFVBJCKIHQSSghBAIBAqEESCAJCenJ7///nuQMc2/uzW1z+3eeJ7n3Tjkz5zNn5nPanDlPOJEACZAACZAACUQMgfMiJiaMCAmQAAmQAAmQgFDsTAQkQAIkQAIkEEEEKPYIOpmMCgmQAAmQAAlQ7EwDJEACJEACJBBBBCj2CDqZjAoJkAAJkAAJUOxMAyRAAiRAAiQQQQQo9gg6mYwKCZAACZAACVDsTAMk4IBAZWWlFBcXS1FRkfGH3+Xl5VJdXe1gi9Ce1a9fP2nRooXs27cvpA60qqpKzp49azA28y4tLfWI9ffffy+///3v5ciRI36P4wUXXCAjRozw+364AxLwhgDF7g01bhPxBNasWSPXXnutXHTRRfK///u/8o9//ENuvPFG+fjjj+XAgQMeCScUYIWq2JOTk+Uvf/mLwRms9d/7778v2dnZbuP75Zdf5KabbpLjx4+7vY23K1Ls3pLjdoEgQLEHgjL3EXYEtNghxPj4ePn555+le/fu8q9//Uvee+89OXPmTMjFCaVfZ7UJwRY7akAcTVrsffv2lWXLltn8paWlCUrt7k6If1lZmVMG7objznoUuzuUuE6wCFDswSLP/YY0AS32hQsXCoSB6cSJE/Laa6/JQw89JCkpKcbxQ/KrVq2SWbNmqb/ExETJy8tTyysqKiQmJka2b9+ufkO8qCqeMWOGbNu2zQgjNTVV5s+fr35DgqgViIuLk9mzZ6s/hG/OTKBZYPny5bJ69WpJT08XHCcyH1gHx7tx40a13bx582THjh3Sq1eveqviUR2OOGM7rI/wZs6cqcLHvswT9rF+/XqZM2eOWgfHcfr0aWOVo0ePyqJFi2T//v2yYcMGxQQMHE1a7DrujtbBPOxr06ZNsmvXLkGc5s6dK9jWfGxghmNGXDAhUwCuP/74o5qP7RBHPeFcoHSPjBvOHZZv3brVON9YD+ug1gDnAussWbJETp06JfZix3neu3evOgc4BvDDb04kEAwCFHswqHOfIU/AkdhxQ//ggw/kvvvuk6SkJBUHCHzw4MHy4IMPyhNPPCGPPPKI/Oc//5GxY8cq2aEE+fjjj0unTp3U+vg9bdo0Of/881XJX4upa9eucscdd6h1IM4hQ4bIU089pWSM8LBPhKlLsBDSY489prZ555135JlnnpG3335bSQiCv+eee+Tuu+9W27/11lvSrFmzesUOGbdr104de5s2bVR4DzzwgNx2220ydepU0SVuCHzcuHEqrogXjuHee++VAQMGKOEhAkuXLpXrr79e3nzzTXnppZfk6aefVtxU5Oz+abFDmhCy+Q+y1NNf//pXefLJJ9Uxggv2CdbIMIApJnMbO44XGaxWrVqpOKF/QfPmzRUHHebhw4dVLcz999+v5uvP2NhYvYocO3ZM+vTpI3fddZc8/PDD6px89tln8utf/9poY8dxIr20b99eHRPSAcLCOTFn3oxA+YUE/EyAYvczYAYfngS02CEciDY3N1cWL14s//73v+W5554TSAETpNeoUSP57rvv1E0cooLkIGItiJ49e6rtsD7C+uijj+SSSy6RF154QZVqIWvUAnTp0kWFWVJSokrjK1euVDUDKEUjQ3HDDTeo9bESxA6xXX755TJ06FCV0UDJ/dChQ3LrrbcqmSUkJKhS7eeffy5XXnmlW2L/29/+Jv3795fNmzer0vsrr7wiN998syEolKyRiRk1apQKGzUXEyZMUCKHWDFpsSOj8sMPP8jOnTtVrYJaaPdPi71JkyaCfZn/wFvLHWLHHzqsYRuUoJFhaNmypdEh0Cz2/Px8JWQwQts7jgGZMZT0MYHx5MmTVdyGDRumwgRvyBvt9Djf6CiJ40f8wQTbgynO23/9138ZYs/MzFQ1ORA7Sv+o8cAn0grW1XGwizp/koDfCFDsfkPLgMOZgBY7buq42UO8uOGjJKaFAzmg1IobOkrzBQUF6g/V1FgfpW6UJlEt+/e//11VwZ88eVKV+tq2batKkxAFqpfRUQ8S0ZOu/ocU0FN87dq10qBBA1WtjHW02B999FGBWPS0YMEC1TMc7dV6QhU1Sq719YrXJXaUhCEm3VYPIV522WVK5JDlu+++K61bt5bdu3cb8cX+wQjNFNhOix0lXRx7fZMWO0r2AwcOtPlDnLUUIXV0XkTGCBNK5MhUIbODpgBMZrFDzMgM4fwgDjo+asVaftgnMmloYtETajt+85vfKM4IA7UhqClAs4KecP7NJXZIHLUj2D9qcHQ6GD58uOp0ad5Wh8FPEvAnAYrdn3QZdtgS0GLv2LGjTJw4UQYNGqSqpVGlrdtODx48qErHkA4Eo/+uuuoq+dOf/qRK5pBhVlaW6umN0j8eN0OJGtXxqPKePn26aj9GiVoLANLasmWLdOjQQVW1o0bg6quvlt/+9reqdAyoWuwvv/yyIT/MR2biwgsvNNqZMQ8ZEPTmd0fsyKSYHxdD1TtKnhA6MgjPPvus6sWOjIiO73XXXSd//vOfVfjYlxY7MipazM4SghY72qUhbfOfrmLHtmCMzJB5WrFihdxyyy2qLwH2YxY7fqNtHZkB8Hv11VdVG7lu+sC5a9y4sTpHZulD5uCH6nbUyqD6Hk0ZKL3rydzGjv3gHOIxO9SeaCb4vPTSSxUrpCVOJBBIAhR7IGlzX2FDQIsdckJVOf5QPY0SPEqiuNFnZGSo32ibRscrVFOb/1BNjfVQ+kYbLUq0CA/fUWWO3vWo4kX7Okr4EAYmZAQgJIhn9OjRSvzffPON/POf/5QxY8aodXQbO9qxzROaASAms1BxDD169HBL7K+//rpqV9ZhogSK0ij6CCBDg8wBqr8hM3Nc8X3dunWqJK3FjvZvXfOgw7P/1GLH9vVNEDuOzTyh4yD6AKAjor3YsR7ijZ71aIpAhgyP1SEuaMdHLQNqJ8DFPCFjAX7opY/zgBqRzp0728SjsLDQ6DyHfUyZMkUaNmyoMn/2TNAMgFoaTiQQSAIUeyBpc19hQ0CLHdXoWk64oaOjHMQMiaHKFZ3UUKLTncucRRDVwnhU7sMPP1SCQikRkkapHXJClS/Cx3xU9aKEjs5fekIJ/oorrqgjdpTqzRMk87vf/U5Vlev5qGqGFN0psaPqGhkWPWFbNAEgAwJBoQ0cpV9U3TubtNjRx0Czc7auJ2JHM4i5dI1mB9QWYD+Yby6xO9ofMhqQNvpD4PjRyQ2ZLdQy6AmcUTOCan5knlCDgSr7nJwcvYrqOY/Oj2jvx37xBAAyYqjGt5/Mx2u/jL9JwF8EKHZ/kWW4YU3AkdgRIbSfo/oXgocQPv30U9WOCtGjGhdV75AAqtzNJTVkEM477zzVyQxV+5ggBHQw+8Mf/qCq5lH6gwjQZozqfFQlo8QMueIZelTv25fY7cWO6nwM8AJhYTtUpWPfEKA7YkepFo/YIS74Q8c8iB3HhGMbP3686g+ATmiIHzI3WA81ECjhYvJG7I6q4lFtrjMGKLH/8Y9/VM+5I06oSsdTAKjV0I8emsWOc4N10KsdDPGHcwTW2BcyUWi2QDMDzgPCBC9wAwNUwyOMr776SlXloxkFNSpYBxm5X/3qV0bnOfRJQB8DNNvs2bNH7Qvh4TE5fWwKDP+RQIAIUOwBAs3dhBcBZ2KHtFH6xo0cz6bj5v3iiy8qEUMKWIZSHtpmIWY9oYSIZ58hKP2oHLZHb3AIG89o69Id1sUjbqg2Rts2SvWo/sYoeK7Ejv1BxmjfRa9xVKGjgxhKlO6IHR0EsW9UP6OJAeGglgGZDkw4NjQhYD0sR9v9G2+8oeI7adIktY43Ykf88Ky9+Q8la505Ajc8aYBH8HBseOQN7djYp35u3Sx2HCeODY/joTYEo9ihdgWlfpTEMaFTHTrGgTMySOB1zTXXyBdffKGW4x+eNHj++edVBgDxROkdnQfNYkdfAN3Egl74eLpBP4KIGhBOJBBoAhR7oIlzf2FBADf0bt26KQlr4eoDh/QhcFQjY0KJFYKBcCB3lK5R6rUfDhXLIWrdUxylOoga+4GI9IRqfQyUAslBOChZYl8QFaSJCTUDqApG1bv9BAl/++23qmQJyaCKGKVUPKKGEqejCfuHqHGMKI1D5ogLnllHadc8IXOD8BAXVM1jXXQG1CV2lGDBABkXe3bmcPAdbd0o6aJjnP0f4ocSNyaIHXFB/PGJ4wRjMNQTalNwzJiH0j7OE/ocgCFK2eCoOz5iG9QG4IkEzIe0ES76SpibVbAO2unRYx/9GfCJmgB0WjQPugO5o0YAbfM4BhwfanUwjxMJBJoAxR5o4twfCYQgAS12lDSdyT+Yhw2xo9TNiQRIwDUBit01I65BAhFPgGKP+FPMCEYRAYo9ik42o0oCzghQ7M7IcD4JhB8Bij38zhmPmAQsJ4B2eQxAg97t5mfgLd+RlwFizHXdhu9lENyMBKKGAMUeNaeaESUBEiABEogGAhR7NJxlxpEESIAESCBqCIS92FFtiGo6PFqDx2z4RwZMA0wDTANMA5GcBjDwER6JddZsFvZixzOrePczXqyBgSb4RwZMA0wDTANMA5GcBjBiIoaY1u+XsK+KCHuxY9QpvL0Jr5HEoBT8IwOmAaYBpgGmgUhOAxjYCS8e0oNdRazYEVFOJEACJEACJBDpBDAsMsSuh1O2j2/ElNgpdvtTy98kQAIkQAKRSIBij8SzyjiRAAmQAAlELQGKPWpPPSNOAiRAAiQQiQQo9kg8q4wTCZAACZBA1BKg2KP21DPiJEACJEACkUiAYo/Es8o4kQAJkAAJRC0Bij1qTz0jTgIkQAIkEIkEKPZIPKuMEwmQAAmQQNQSoNij9tQz4iRAAiRAApFIgGKPxLPKOJEACZAACUQtAYo9ak89I04CJEACJBAMAlXV1VJZVe23XVPsfkPLgEmABEiABEjAlkDe2TIZu2KvDFycJkfzim0XWvSLYrcIJIMhARIgARIgAVcEUg7ny7V9lsjVvZfI9xsPulrdq+UUu1fYuBEJkAAJkAAJeE5g66E8+Vf3xXJZ98UyZc0BzwNwYwuK3Q1IXIUESIAESIAErCBAsVtAEe+jbdSokfC1rRbAZBAkQAIkQAI+EaDYfcJXszHFbgFEBkECJEACJGAJAYrdAowUuwUQGQQJkAAJkIAlBCh2CzBS7BZAZBAkQAIkQAKWEKDYLcBIsVsAkUGQAAmQAAlYQoBitwAjxW4BRAZBAiRAAiRgCQGK3QKMFLsFEBkECZAACZCAJQQodgswUuwWQGQQJEACJEAClhCg2C3ASLFbAJFBkAAJkAAJWEKAYrcAI8VuAUQGQQIkQAIkYAkBit0CjBS7BRAZBAmQAAmQgCUEKHYLMFLsFkBkECRAAiRAApYQoNgtwEixWwCRQZAACZAACVhCgGK3ACPFbgFEBkECJEACJGAJAYrdAowUuwUQGQQJkAAJkIAlBCh2CzBS7BZAZBAkQAIkQAKWEIgasZ85c0Y6duwoF154ofF3+eWXS0pKigJZXFwsb7zxhlx88cVy3XXXyddffy0QtjsTxe4OJa5DAiRAAiQQCAJRI/aCggJ59913pXPnznLixAn1l5OTIxUVFVJdXS2vvPKK3HvvvbJu3TqZNm2aNG7cWGbNmqWWuToRFLsrQlxOAiRAAtFNoKq6OmAAokrs77zzjhJ4WlqaZGRkCGQPqUP0F1xwgaxatUqBLyoqkk8++US6dOkiJ0+edHgyqqqqpLKyUv0VFhZKo0aNJDMz0+G6nEkCJEACJBC9BPLOlsnajBw5XlASEAhRI3bIt0+fPtKkSRN56qmn1N/w4cOV1FesWCHnn3++TdX7N998I+3atZM9e/bUOREQP0r2c+fOVX8zZsyQSy+9lGKvQ4ozSIAESIAExq7IkKt7L5H+P+8MCIyoEXt5ebns2LFDdu7cKfv375c5c+aoqvfZs2crOaPt3TxB1q1bt1brm+fjO6rwx48fL6+//rr6a9++vVx00UUUuz0o/iYBEiABEpBnxq+Vf3VfLO2nbgoIjagRuz1NtK136tRJPvzwQ1mwYIGqii8tLTVWmzJlirRt21bS09ONefoLqu+RUcD6+Dt9+rTccMMNFLsGxE8SIAESIAGDAMVuoPDvF4i9Q4cO0rVrV1UqRxt7cnKy2mlJSYkMGDBAdbTLzs52eSDsPOcSEVcgARIggaglQLH76dSjXXzmzJmqBI5OblOnTpXbbrtNVcND5C1atJBWrVqpx99++ukneeyxxwTt7CiZu5oodleEuJwESIAEopcAxe6nc4/q8meffVZuuukm1YO9WbNmStyYj+ngwYPy4osvqmfYb7/9dhkyZIjqWOfO4VDs7lDiOiRAAiQQnQQodj+dd7SLo2QOCeMP3/G4mnlCezmWYbAad0rqeluKXZPgJwmQAAmQgD0Bit2eSBj8ptjD4CTxEEmABEggSAQo9iCB92W3FLsv9LgtCZAACUQ2AYo9DM8vxR6GJ42HTAIkQAIBIkCxBwi0lbuh2K2kybBIgARIIHIIYIj4+4et5AA14XZKKfZwO2M8XhIgARIIDIHMnCIldY48Fxjelu2FYrcMJQMiARIggYgisCztOMUejmeUYg/Hs8ZjJgESIAH/E4hNPUax+x+z9Xug2K1nyhBJgARIIBIIUOxhehYp9jA9cTxsEiABEvAzAYrdz4D9FTzF7i+yDJcESIAEwpuAWewPjkiQhVsOS27huTeJ+iN2UfvaVithUuxW0mRYJEACJBA5BMxiR8/4K3rGyMSEfX6NIMVuAV6K3QKIDIIESIAEIpCAvdgh9zEr9vo1phS7BXgpdgsgMggSIAESiEACFHuYnlSKPUxPHA+bBEiABPxMgGL3M2B/BU+x+4sswyUBEiCB8CZAsYfp+aPYw/TE8bBJgARIwM8EKHY/A/ZX8BS7v8gyXBIgARIIbwIUe5ieP4o9TE8cD5sESIAE/EyAYvczYH8FT7H7iyzDJQESIIHwJkCxh+n5o9jD9MTxsEmABEjAAgJ457qziWJ3RibE51PsIX6CeHgkQAIk4CcCpRVVsnrvSdl/stDhHih2h1hCfybFHvrniEdIAiRAAv4gsD0rT67sFSsfzN3uMHiK3SGW0J9JsYf+OeIRkgAJkIA/CPyQlKXet95m8kaHwVPsDrGE/kyKPfTPEY+QBEiABPxBgGI/6xDreQ7nhtFMij2MThYPlQRIgAQsJECxU+wWJicGRQIkQAIkEGwCIS32HotlytoDfkF0/PhxadiwoaBg62hiid0RFc4jARIgARIIeQIUO8Ue8omUB0gCJEACJOA+AYqdYnc/tXBNEiABEiCBkCdAsVPsIZ9IeYAkQAIkQALuE6DYKXb3UwvXJAESIAESCHkCFDvFHvKJlAdIAiRAAiTgPgGKnWJ3P7VwTRIgARIggZAnQLFT7CGfSHmAJEACJEAC7hOg2Cl291ML1yQBEiABEgh5AhQ7xR7yiZQHSAIkQAIk4D4Bip1idz+1cE0SIAESIIGQJ+CN2L9cvleqq/0Xta2H8tQb5y7jkLLeQ+ZLYLxnxy1JgARIIJwJeCP29+Zsk19Sjkl2fon4w+8UuwUpimK3ACKDIAESIIEwJOCN2P/VfbEqUc9NypLyyirLY02xW4CUYrcAIoMgARIggTAk4IvYJ63aJ8XllZbHmmK3ACnFbgFEBkECJEACYUiAYmfnuTBMtjxkEiABEiABZwQodordWdrgfBIgARIggTAkQLFT7GGYbHnIJEACJEACzghQ7BS7s7TB+SRAAiRAAmFIgGIPIbFXVVVJtd0IAfiN+Y6W1Zfe2HmuPjpcRgIkQAKRS4BiDwGxQ9qrV6+We+65R5o3by6ZmZkqxR09elRat24tDRs2lFtuuUVGjhwpubm5bqVGit0tTFyJBEiABCKOQEiLvftimbLmgF+YHz9+XPkS/nM0nedopj/moUR+8OBB6dWrlxJ7mzZtlNgrKyvlmWeekRYtWsi2bdtkwYIF0qxZM5kyZYpUVFS4PBSK3SUirkACJEACEUnAF7F/5e/n2KNB7AUFBTJhwgTp27ev9OvXT9q3b6/EnpWVJRdccIFs2rRJJbzi4mLp37+/vP3225KdnV0nMSKDgMxAeXm5+kO4N9xwg1H6r7MBZ5AACZAACYQdAbTW7jpWIEmZp5yOEDd3c5YaRa7N5I0O4xebekwt16PNmT99FXtFVbWkHM6THUfybY7PGKAm0sWOkndcXJx06tRJUlJSZNy4cYbY4+PjldhLSkqME4PSetu2bSU9Pd2Yp7/k5+fL/PnzZfDgweoPmYSLL76YYteA+EkCJEACEUCgorJaXpi0QZ4ev1ZSDuc7jFEwxb73RKG0n7JJnpmwTnIKS43jixqxoy391VdflYULF6rOcWaxY96FF15oQMGXGTNmqDb3nTt32szHD4q9DhLOIAESIIGII1BWUaVK23cMWi4/JB12GL9gij0+7bg8OCJBHeORvGLj+KJG7Gg3/9vf/iZPPvmkvPjii3LbbbfJZZddpn7PmzdPzj//fEEVvJ4mT54s7dq1kz179uhZxier4g0U/EICJEACEUsg1MW+NNrFvm/fPlUKnzlzpuAP7ev333+/fPHFF7J//35VFb9mzRqVQNEZrk+fPvLuu+/KiRMnXCZadp5ziYgrkAAJkEDYEaDYnZ+ykOgVj8fcdGc3fH755ZeqRJ6RkaGq5tGe3qRJE9WBDuJ/8MEHVUYA27maKHZXhLicBEiABMKPAMXu/JyFhNjtD8/cxo5lkDNK8RdddJFcccUVMn78eCkqKrLfzOFvit0hFs4kARIggbAmQLE7P30hKXbnh+v5Eordc2bcggRIgARCnUBAxF7m/fvYo76N3Z8JiGL3J12GTQIkQALBIeBvsU/EADUUe3BOrqu9UuyuCHE5CZAACYQfAYrd+TljVbxzNlxCAiRAAiQQogQoducnhmJ3zoZLSIAESIAEQpRAuIsdw9dG/Etg/JV2WBXvL7IMlwRIgASCRyASxD450t/u5q/kQbH7iyzDJQESIIHgEXBH7HM2H/L6JTD+7jyHEjvF7mX6odi9BMfNSIAESCCECVDszk8O29ids+ESEiABEiCBECVAsTs/MRS7czZcQgIkQAIkEKIE/C32cSszpLC0wuvYuxqghlXxXqOtGY62UaNGfB+7Dwy5KQmQAAmEGgF/i73D9CSJTT0mVdXVXkU9ZscxuX/YSqevbaXYvcJasxHb2H2Ax01JgARIIEQJ+FvsEC/+isu9G1YWj7Ld2G8pxe6P9EOx+4MqwyQBEiCB4BIIdbEPj9stDXrGUOz+SCYUuz+oMkwSIAESCC4Bit05f3aec86GS0iABEiABEKUAMXu/MRQ7M7ZcAkJkAAJkIAbBKqrq6W8ssqNNa1bJZBiR/e58opz8auoqpaqKued6iqrqmVI7C5WxVt3um1DYlW8LQ/+IgESIAGrCaA9+eFRq6WgpNzqoJ2GZ4XYl6QeU23guqOco8/M3CKZl5wlrSauk6TMU7LrWIF0nrlFvlq1T86U1H0c7uSZUiX1RrUd5xDmkbxiIx5bD+UZ++TIcwYWz75Q7J7x4tokQAIk4CmBFyZtULJaseuEp5t6vb4lYt/pWuzItFzRM0Yu675Y3pyeLDM3HpTLe8TI3UOWS8rh/DrHH592XK1vziRQ7HUw+TaDYveNH7cmARIgAVcEnv9qvRL7srTjrla1bHmgxD40drdRwn5tWpJM33BQ/b5z0HLZnpVXJz5Ld2bLZT1qHpXTcqfY62DybQbF7hs/bk0CJEACrghQ7OcIUeznWPjtG8XuN7QMmARIgAQUgVAV++xN9b/dbYkbVfEssYdgIqfYQ/Ck8JBIgAQiioBZ7BipbVX6STmYe9Yvcdx66LRs3J8r7lTFWyH2vj/ttKwqHqPTrs3IMcJj5zkvkwjF7iU4bkYCJEACbhIwiz1x70l5cESCjFya7ubW7q+Gl7K8OT1JHv8yUUorKpUg7xi0XH5IOuwwECvE/sjo1YaIfW1jLyqtkD6LUo3wKHaHp831TIrdNSOuQQIkQAK+EDCL/avV+5W4OkxP9iVIh9tm55fIw6NWqfADVWLXHeDw6avYc4vK5KGRNceP8Ch2h6fZ9UyK3TUjrkECJEACvhAwi31Cwj6/if1YXrH8J5zFXlgqjYfXvPGNYvchxVHsPsDjpiRAAiTgBgGK/Ryk+nrF51Ls50D58o1i94UetyUBEiAB1wQo9nOMKPZzLPz2jWL3G1oGTAIkECYEKiqrVHvuom1HBT2zrZ6sFPvOo/nSY36KDI7ZJT9tOyLmw2VVvHtnji+BcY8T1yIBEiCBsCVQUFyu2r2f+2q95BdbP567lWK/d+gKdaxog35m/Do5W1ZpcA8lsaM3vqcjz7Eq3jiVvn1hid03ftyaBEgg/Ankn60Re8sJ6ySnsNTyCGmxx6dli6+d5yBMSB1/T49fK4WmF8t4LPbNvg9Qo48Fn+Ze8d6IHezvH8bOcz4nQIrdZ4QMgARIIMwJBFbsGUrK3j7uVp/Yj3rYK35OEMQeV89Y8RS7RRcSxW4RSAZDAiQQtgQo9o0Oz507Q8qyxO4QXXBnUuzB5c+9kwAJBJ+AlWIvLquUvcfPyNnSc+8i11XxKCG/O3trvSX26upq2Xm0QL3LPO9smRzIKZKS8nPt6O6W2NG+Dene2G+pTEjIcAhZl9hbjFsreK86Rq7bf7JQztRW73sq9le/3SzfrstU+72m9xKJ2XFMKqrM3ftEUGI3ZwbwHT3l0VfgyOliuf7TOGM5B6hxeNpcz6TYXTPiGiRAApFNwCqxo3f9wq1HpPmYNfJN4n4DmhZ7k5EJSrSQmbOq+JW7T8hjXybKu7O2yqTV++XJsWtkccoxIyx3xf7oF4lKkA16xsjH8/XReNoAACAASURBVFKkoqrKCEN/mV1bFX9dnzjpOCNZei3cofY3Z3OWykx4Kvamn6+SDtOTDDH/5/NVgtHw9FRVXS0/bz9qLNeCx2hzGEq27TcbbZZR7Jqch58Uu4fAuDoJkEDEEUDJGJLxtfMcSp3vz9mmwur9Y6rBSYtdi6w+sX/0w3a1/W0Dl0m7yZvUd7Pg3BW7eV+dv99i03teH5geKx7roqSM0j2+d527TU4VlYmnYm/4SaxNiRthmV92U15ZJeZ9mo/x6t5L5PIeMWr/er453vqYrfjk425WUGQYJEACJBDCBAyxT1wneOTK2+lsWYV0mpms5OSt2N+euUVtf8uAeHn+qw3qu1lwXol95hbBC1bsJ7Nkr/okVq7ps0Tt7+3vt6inA2JTj6nfWrSuPiHmK3raytks9rLKKvl+40G3wzTH2/7YfflNsftCj9uSAAmQQBgQCGex6/ZwYDb3ijdLuDPFbpMKKXYbHPxBAiRAAv4jUFlVLWiH9XVCCAjL3SmYYkd8zXH2tMTuL7EfLyhRnd/MGQRX31lidzfF+Xk9trH7GTCDJwEScIsAXjO6YX+u4H3lpRV1O3q5FUjtSunZBUpKp8+WubVZsMSOeCYfPC1r9uYYVeU+i/3zc6891SL2tMTeauJ6mbXxkAyO3eV2tTn25Ujs6Ayo82rogzBhVc3b7fSx1ffJqni3km/dlSj2ukw4hwRIIPAE0rPPqM5rN/ePl+yCcz2pvTmSD+duV229C7YedmvzYIl9d3aBtJm8UW7/bJmkHslXx+qL2PG4GHqi28vSU7Hbb+/ub0dif2LMGuORt0OnzkqrievqHJ+z8Cl2t5Jv3ZUo9rpMOIcESCDwBFamnxA8LoWbPNqKfZne+K7mkavPFu9yK5hgiT0h/aTgETjEOengaXWskDB+e9N5LhTFjrigNzwmPJ+P59sxz50/it2t5Ft3JYq9LhPOIQESCDyBYIodVfYQTUvVK9696ntHhNArvrMHveIdi72mVz3E/sIkz3rFU+yOzkrdeew8V5cJ55AACZCA5QSCKvYiLfb16vltbyNHsdd93M2+xI7n1d0prWMdlti9TIkssXsJjpuRAAlYSiAUxI5OYxiYxdvJJ7FnnlK71SV+2xL7uVHs6nuO/cjps261sWPYWkyzNtW83Q0SNT/H7q547ddz1MaOdcoqaobERVU8xe5t6vJgO4rdA1hclQRIwG8EIk3sGJ51xoaD8s73W1TnOHsJYkhZc1X8E1+uETxipsV+bZ8l8sDwmvb3WwfGy+hleyTvbLk4E/uWg6fl2Qnr6ozehv2aO8+h/8LLUzbJTf2X2rR3WyX2K3vZDlCD/T/0eYKg4xzF7rfLxzZgit2WB3+RAAkEh0Ckif21aZuV1O2Frn/bix3zMdKbHrlOr2f+3JaVV0fs+jn2T3/a6bSK2yz2AYvTbISuw7dE7D1jxJHYsQ+MRU+xm66tqqoqycnJkf3798vevXvlwIEDcurUKcF8TKhWyc7OloyMDLUsLy/PWGYKxuFXit0hFs4kARIIMIHIEHul6MfV8KYzDM2qxWn/qcX+UG2veCyH2CFA+3X1byvE3u/nnQ6rw/0tdrwcJiLEDgm7+oOsXU2Q7+effy7NmzeXpk2bSrNmzeTDDz+Uffv2KamnpKRIy5YtpXHjxvLQQw/Jp59+KllZWa6CVcspdrcwcSUSIAE/Ewim2NGuDnn63sbuu9jfmh7ZYg/7x93at28v+u+FF16QJ554Qlq1aiUvvfSSPPnkk0rUXbp0cXm5lJeXy7Zt2yQ9PV2VzNevXy8PPPCATJw4UQoLC5XsX3vtNbU8Pj5ennrqKRk/fryUlrp+mQHF7hI/VyABEggAgYQgPsd+qpBiD1SJPezFPnnyZMHfyJEjpUWLFkrqw4cPl3Hjxknv3r3lpptuUiVvT64ZXe2O8MaMGSM7d+6U888/X3bs2KGCgcwHDx4sHTt2lKNHj9YJGtsjo4D18Hf69Gm54YYbJDMzs866nEECJEACgSLgidgListlWdpx9QYyR8fn6QA14Sp2jOp2rPZ95/W1saNZAB3zMPmzKv6yHovlcru3u+lmBF0VH/Zi1wlu06ZN8vbbb0tycrJUVtZ0+y8rK5Nvv/1Wld71evV9Yv2VK1fKO++8I61bt5bXX39dyTwmJkYuuOACwXI9TZ06Vdq2bSu7d+/Ws4xPtNWjNI/t8YcahYsuuohiNwjxCwmQQDAIeCL2cSszBG3TePe5oylaxI7hd79JrGnOrU/sdw5aLvOSa4bX9afYtcQdfUac2OPi4pSMjxw5YpMGUaXesGFDm3nOflRUVEhqaqqqfu/atauq1k9ISJB58+bJhRdeaLPZjBkz1P5QmrefioqKZO3atTJ37lz1N336dLn00kspdntQ/E0CJBBQAp6IHW3hl3VfrHpgOzrIUBF7Zxed51btOSkPjTw3tjs6z3nSxg6Bvjt7q0JQn9ix3vC4dLUexS5iychzmzdvlkceeUT69eun2sERaGJiojRp0kRefvllR+nS4TyU9ktKSlSPeHSee/fdd+Xnn3+WX//61wJh6+nrr7+Wdu3aqY57ep75E73pERb+0EbfqFEjit0MiN9JgAQCTgDPdOsXmLgaK/6pcWtVZ7cGPWMcHmdQxV4rc1R/eyr2Jd6IfRbF7jAR1DPTErGjmhwCvueee+R//ud/1N9f/vIXefXVV+XkyZP17N75ImQS0AkPvep/85vfyLJly9TKEHWPHj3k/fffl9zcXOcB1C5h5zmXiLgCCZBAAAisotgFYkeVtaOqbMyzf9xNldgpdo9Tp89iR2e1EydOyPbt26WgoECVjNHRLT+/5hV97hwRtkOHuHXr1qnq+ClTpqgOb+iEhw5waHe/7bbbZPny5TJhwgS57777ZP78+e4ELRS7W5i4EgmQgJ8JBEPsVdXVgj9LO8/5WGL3RuwYIbbPIucD1OiqeMS17094jj22TubBil7xzjIkmB9xbexLlixRpXMMKuPNBLGj892dd96petLjeXa0jZ85c0YFh+r5bt26yS233KKq92fOnCnFxe699pBi9+aMcBsSIAGrCfhD7INinL+2tayySmZuPCQ/bj0iuYWlxnPseNObt9PZskpjUBpvq+K9EfvOo/nGm+CcyXVw7C5Zvuu48ZpY+/Uo9nNn/bxzX51/Q294VI2j0xrawtERTv/pXvLOt/bvEordv3wZOgmQgHsEAi32HUfy5b6hK5XQc86Er9jRjj92ZUadEri9uDFmPTIb9vP1byV2D968prdz9zPiSuy7du2SZ599VvVkHzp0qEyaNEm++eYb9YfSdTAnij2Y9LlvEiABTQA9xK3uPFdfiX313pNy1+DllosdAoXs3C2xNzX1ivemjb3TzC3y5Yq9ToWtxYvjebH2/e56nvmTYtcpUcStEvvWrVulTZs2Dv86d+58LrQgfKPYgwCduyQBEqhDgGJf7FXnOYq9TlJyOcPnznPYA9rA8Qy7oz+8vCWYE8UeTPrcNwmQgCYQkWKfWf9LYBBnltgXO61tmLzmgE4eln5aInZ9RGhXx8hvBw8eVL3jMYyruy9r0WFY/UmxW02U4ZEACXhDINBiT3SzKr68skoyThSq3vP4fiCnSP2VVtS8XdMcV3Se01Xxr+A5dg/FHrfzmLz5nfPH3X5JOSp4N7u5Cr3t5I3ianAarO+qKv7yHjGCcQHMYVv5HfHC2908GVJ21LI9UlJeM1qrmbOv3y0RO8Zmx8tZnn76adWrHWOz6z+8zCWYE8UeTPrcNwmQgCawOsBt7Gaxn6yn89yYFRny8KjVMmdzliQfPC1NP1+l/mZtOqQP3fi0Qux6cB1HUr136Aq5wk6+130aJzcPsJW9o21did3RNlbO80bs//5smcSnHZfKqmqDsRVfLBE7nlt//vnn1etUH3/8cRkwYIAaGvaqq65y+3lzKyLjKAyK3REVziMBEgg0gVARe57d426PfpGoSrEPjlgp09ZlGiXaMSv21kHkqdgRZ2QUtEBRYq9P7Ho9bz7DUeyIJ6rjrS61WyJ2lNYxyhzetvbmm2/KrFmz1BvWFi9erF7dWid1BHAGxR5A2NwVCZCAUwL+EPvgmLovwtIH4KzEbi923VMfPeinrDlgSNiZ2N+dtVWt405VPMXuvH1dZ17wkptii6vjLRH70qVL5Y033lBjvH/00UfqdasYXAYl+QYNGuh0FpRPij0o2LlTEiABOwIU+2KJhhL7tX2WGJkjLe/6PkNW7ElJSdK9e3f1UpbvvvtOvZcdn3gBTMuWLe2Sd2B/UuyB5c29kQAJOCagxD6qplq6vpfAYPhUd18CwxL7uRJxKFTFpx0tkIgRO4aSxdvcDh06pF760r9/f1UF/8ILLwikH8yJYg8mfe6bBEhAE6gR+2pVmnMmdox1vvFArjQeXjNinKu3uwVV7FM3C54xd1YafX1akhri1baNPdtvbeyPf5loDADk7Jj8OR+d5yJK7OgVbx67HY+94fl186tWdeIO9CfFHmji3B8JkIAjAu6IHeO4o+R5WY+akmg4i/3ZCetUxzB7sUP4/hRssMKOOLHjzW54d/qYMWPUY294dj3YY8TrC4ti1yT4SQIkEEwC7oj9UO5Zef6r9Yb4fBH7GtNz7CfOlKgwn5u4XurvPLff2LfLznMuSuwQ+oBf0mxK0XE7s4ViP9d8gExIyLaxowp+5MiRSu6tWrWSxx57TPWSHzVqlKxevTqY1xJf2xpU+tw5CZCAJgCx43lx3MydVcX7S+zHC2rF/tV6yS8u14ekPm17xVPs3pb49XPsEdPGXlVVpardMaRsWlqaxMTESLt27eTiiy9Wr2K1SUUB/sESe4CBc3ckQAIOCfhD7ENinT/uZi6xU+y2pWRv5V3fdobYPXyD3DeJB0LzcTdUu2MYWbxD/fXXX5frrrtObr31VvUdz7QHc6LYg0mf+yYBEtAEKHY87hbZVfEYUvbaSBE7Suh//OMf5eGHH1avbD1w4ADb2PXVzE8SIAESEBF7sXeblyKfLkpVbDJzi6TPolQZuTRdnhm/zmjndtXGjhLksDjHpXZXJfasU2fl6fFrjX3dqQaoCURVvPN3ptdXIg71Zd52nsNY+K2/2SiZOUWWXSeWDFCTkpIiLVq0UOPE43PQoEGybNkyOXz4sBq0xrKj9SIglti9gMZNSIAELCdgFvu+k4Wq5/vtny2TnDOlsjjlmBIsxkq/qf9SQ7buiL3hJ7EOj3VtRo7xPnZHVfHd5qcY+4E0IfbJiR6KfYbzx92cd56j2B1lUpCxs2qyROz6YHJzc1X7+vvvv6+q4//6178KnmUP5kSxB5M+900CJKAJYIhX3Xlu74kaseMlIOixrsV+x6DlckPf8BB7+6mbpaMLsQ+06xW/NC1bXvs2MsWOMfDxHPt1n3o28pyW/MfzUnRS8fnTErHjeXU88hYXF6de/vLxxx9LmzZtBG92wxjywZwo9mDS575JgAQ0gWCKPdtBr3hvS+xdZteMFU+x23bIizixoyr+tddeUzLv0KGDDB48WL3VLTU11WbgGp3AA/lJsQeSNvdFAiTgjECoiL2g9nE3it1WzLrk7O1nxIkdj7ktWrRIldpPnz4tePwtVCaKPVTOBI+DBCKTAN6ljSpY/JVVOL/3mcW+YvcJuaz7YnG3Kh5v/9qelScZJwoFb+42v/rUnTZ2c4ndmdgb9Vsqw+N2G+3uzgaocbfEjr4CL0zaIPcNrRkeF8KM9Kr4LYdOy5W9Yg2GnmQSQq4qHpcrhP7LL7/IwIEDBSV4yH3NmjWSkZER1KuZYg8qfu6cBCKewK5jBfL291tUb/bdxwqcxjdxb47Rxt58zBp181diLyiRn7cfVb9v7LdUrjE9LqU7z2EfLcaukf4/pwk6wvlD7Jf3iDHGqIeQnIldv7bVVVU8wrjqk1j1pwUXyWJH7/bhS85ljHSc3f0MObGj0xx6wjdv3lz1jJ83b55gvPhJkybJhx9+6DShB2IBxR4IytwHCUQvATybffeQ5UrMGw+ccgrCLHZ9s4fYIeqfttWIHaXvK3rGGCU+LfbNmafUvJe+3qBqBvwhdn1M+tMKseuw9Gcki/35Seul1cRzjyrqOLv7GXJiX79+vbzyyiuyatUqNeLc3LlzBS+G2bhxo9xyyy1OE3ogFlDsgaDMfZBA9BKI2XFM8NgabuDein3RtiNqe1TjQuZaBvZif/6rDZJ6JN8vJXa9T/3pWuybpOOMZONY9Xb1fUay2J/7ar08ObamJqY+Bs6WhZzYY2NjVe/3/Px8eeONN0SLHQPVXHLJJUG94in2oOLnzkkg4gmEqtjX7cuRuwfX1CS408ZuLxxnYj/Xxu6d2PH2Ovt9RcLviBM7Suoose/cuVP1jp89e7acOXNGxo0bJ82aNQvqhU2xBxU/d04CEU8gEGLfsD9XydCTErtZ7AdzitT2rSaul9zCUkGHP/te8fZyHR6XLsVllYJ3xOvpbFmlUOyOe9NjFL9HRyd6nWkJuRI7Rpjr3r27dO3aVZo0aSLdunVTj7w1atRIfvzxR50mgvJJsQcFO3dKAlFDAIPLoK0cYvRHVTxkOnrZHp/E/lnMLrX9A8MTZPKa/bLjcJ5LseOtb0OX7LZ5E52vYo9Py1bvm7fPRPD3Ygk5seMK3r9/v/Tr1091oGvatKk8++yz0r9/fzUSXTCvcIo9mPS5bxKIfAL+Fvvh08VGKdDjEnttpz57cQ5bsls++GG7Ea79cvNvPKanJ9/Ffpxi7+64xB9SYkeV+/Lly2XOnDmSmJgoWVlZ6jE39IjHq1tffPFFnSaC8kmxBwU7d0oCUUMgVMW+Hm3sTsSO1712nbPNLbFjjHtdGW+F2F+Zusmt/ZozF9HwPWTEjp7vkydPVtXvd999tzRu3FhGjBihHnHDCHTjx4+XLVu2BPUCp9iDip87J4GIJ+Cu2NfszZFmo1bbSE0/7lZfr3hvS+wUu+OScahmEkJG7AUFBfLYY4/J6NGjVVv6I488osaH/+6779TANKEwAh3FHvH3VUaQBIJKINrE/t7smpL+y1M3yVsePu4Wn3ZcWGJ3nOEIGbFjtDk8p47OcxiQpkePHqoT3alTzgdpCPQVSLEHmjj3RwKRSaCiqkryzpYZ1dI6lotTjrrVec6bEvvlPWMkPfuMUcp31sZebeq5ro8LA+fo5+vtS6m9f0yVTvW8mc28/rzkw8ZQuaiK90Xsy9KOyx21HQ3N++D3EOo8B4Gj5zueX8eEznNffvll0F/8ohM2Pil2Mw1+JwES8JbAwMW75P5hK5VozWH4WmJPOZynhqSF3BraDVCDeXiVqxafI7FjEJtxK22H7s46dVbaTdlkM9iNDgOf138aJ9f0ce/1ojf3j5dPFqZKRWW12Ih9iucldvC7rIfjEqv5+KLxe/upm8zJyqfvPr22FWL/85//LE899ZS0atVKvYP95ptvVj3i8Rt/GLAmmBPFHkz63DcJRA6B1t9sVIIdFb/HJlK+ih0lay07R2I3S+75r9bLDruR57D8wREJNsc0NynLJkNgDsOb7zi+kvLKumKf7tnIc97sO1q2cfYyH5sT6+YPn8QOaXbp0qXev08++cTNQ/HPahS7f7gyVBKINgJa7J9bLPYlqdlGiRxiN48Vby81Z2JvPNxW7HM2Wyt2HAfF7t+ahis/ibXskvJJ7JYdhR8Dotj9CJdBk0AUEXAudt/a2Cl2/wrTPnMUqr8pdg9uJhS7B7C4KgmQgFMCFDuq4ivkvdrn319GGzur4o3aFl8zDBS700uv7gKKvS4TziEBEvCcgD/EfkPfOOmzKNWQg7dV8bcMiJdp6zKNP4znjrB9lY15++/WZ8rXifvVe+Exn2K3tqYBb/azamJVvFUkGQ4JkEBEE/BV7GszcqTZaNsBatAp7apPYg0Beyt2s4D99d18nBS7tVIHzwY9Yiy7fih2y1AyIBIggUgm4Ezsv6QcldsGun4JjCOx20s4lMVuf6wssVsvd6uuH4rdKpIMhwRIIKIJBELsKBV70yveXrqB+E2xU+xBu+DZxh409NwxCUQUAWdid3fkOZbYrRdhIDIwgdyHVRcMS+xWkWQ4JEACEU2AYrcVM0vstjysyABYdQFR7FaRZDgkQAIRTcAKsT9i13nOXgauquKbjlwlb36XZLTp22/P39bLNpBMrbqAKHarSDIcEiCBiCbgTOyedJ7zVeyBlAz3FfhMglUXUEiIHW+G27VrlyQkJEhcXJysWbNGjh07JpWVlUY8S0tL1bvdsXzVqlVy9OhRcee1sGxjNxDyCwmQgA8EKPbAiy7aMhc+JE+bTUNC7Hg7XKdOnaR9+/byyiuvyPPPP69e/5qVlaUOFq8k/PHHH6VFixby0ksvqZfM9OrVSw4dOmQTGUc/KHZHVDiPBEjAUwIUO8Xu74yGp2nS2fohIfbi4mJZtGiR7NmzR06cOKFK7o0bN5YFCxao97xj+b333isDBw4UyH758uXyxBNPyIwZM6SsrMxZ3NR8ir1ePFxIAiTgJgGKnWKn2N28WBytdvr0aSXuadOmSXl5uWzdulX++c9/SmZmplod1fIffPCBfPzxx5Kbm2sTBEr3kD0yA/jD8htuuMHY1mZl/iABEiABNwlosY9cavva1oVbj8iN/Zaq0eM2HjhlhHampEJ+SMqS2ZsPyYIth2VCQoY0GZlgjDLnSBKuOs852obzIifDYSQeH7+ERIndHAdd7d60aVPZuHGj4PcPP/wgDRo0sGlzHzp0qHrX+5EjR8ybS3Z2tvTu3VseeOAB9Xf//ffLH/7wB4rdhhJ/kAAJeErAmdhnbjwkDXrG1BH7hIR96p3ot3+2TO4avFzuHLxcru69hGLvHjkitjpT5WmadLZ+yIl9/fr18uSTT8rYsWOlsLBQHffMmTPlyiuvtInDyJEj5dVXX5XDhw/bzEdpfd++fZKcnKz+1q5dq7bVpX2blfmDBEiABNwk4Ezs360/aMjaXGJ/evxaY767AmCJPbql72ZSdLlaSIk9JSVFSX3QoEFSUFBgHHx8fLxccsklhuixoG/fvtK5c2dBBBxNKOnjj23sjuhwHgmQgKcEPBX7Y18kUuwsnXuUBjxNk87WDwmxQ8BpaWny9NNPq3ZztLHjUTbMx5SXlyeXXnqpLFmyRHWmQ3V769atBaX2oqIiZ3FT8yn2evFwIQmQgJsEKPboLk27W+viy3puJkWXq4WE2E+dOiXNmjWT++67T+bPny8rV65UfwcOHFDt6hB89+7d5ZFHHlE94Xv06CHNmzeXzZs3u4wgxe4SEVcgARIwESgur5Sq2kKFabZosQ9cvMs8WxxVxVdUVctDLjrKORIAq+KjO/Ngk7B8+BESYkfP9ccee6zO3/Tp0wU94DFB/oMHD5aWLVvKW2+9pQapQY95VxPF7ooQl5MACWgCJ8+UypQ1B8TcVq6XabE//mWiZOcXq9nIAExde8CobtXb/bT9iHq/tiN51zePYqfYdXrz5TMkxO5LBFxtS7G7IsTlJEACmsDkxANyWY/F0mriej3L+NRih5i/XL5XzT9bVimjl+2pI/YretX0kq9P4o6W4ZWtl/fwbltH4XFeeGUUjMTm4xeK3UeA3JwESCByCHSdu01Jutno1XUiZRb7G9/VNAPmFZfLZ4vTLBM7pI6MBYUcnQzqJDovZ1DsXoLjZiRAApFHgGKPTqGGSkbKqiuKYreKJMMhARIIewIUO8UeTMlbdQFR7FaRZDgkQAJhT8CZ2Msrq+TFSRuMKnLbqvhdxnzdec7bNvZgSoX7Dn6mxqoLiGK3iiTDIQESCHsCH8zdriRtbmNfm5EjT41bawwbCwHeNnCZimtNGzvFzkyBNZkCqy4git0qkgyHBEgg7Ak4EvuIpelGiVwL7OYB8SquFLs1QtNco/3TqguIYreKJMMhARIIewKeij1f9YpniT3ahWxV/K26gCh2q0gyHBIggbAn8MEPdavi6yuxK7HHUOxWiS3aw7HqAqLYrSLJcEiABMKeAMXOqvVgZi6suoAodqtIMhwSIIGwJ+Cp2PPOlsmAX2wHqMEw8+wVzwyCNxkEqy4git0qkgyHBEgg7Al86GFV/P6ThfLK1E1G5zo87paZUyQYGtabGzu3ie4MgVUXEMVuFUmGQwIkEPYEPBX79qw8eWT0akPiEPvGA7k2j8ZR1tEta0/Ov1UXEMVuFUmGQwIkEPYEPBX7tqw8aTbKVuwb9lPsnsiM657L+Fh1AVHsVpFkOCRAAmFPwBux25fYKfZzoqK0PWNh1QVEsVtFkuGQAAmENYGKqmp5f47t293wvvVhcQ4GqOkfLxhmNvng6TpV8YkZOayK7+6Z0JgBqOFl1QVEsVtFkuGQAAmELYHSikoZs2KvNPwkVrWXY0hZSD0p85Q8M36t0YauBXTVJ7HSa+EOlRFoMiLBWI429vZTN8llFJvBRDPjp+vMjlUXEMVuFUmGQwIkELYEUo/kyz1DVhgygtiLSitkVPweY547YoLY7x+20qNt3AmX67iWYiQwsuoCotitIslwSIAEwpbApgOn5M7Byw0hQ+wFxeUyNHa3Mc8dcVDs0SFgd9KCN+tYdQFR7FaRZDgkQAJhS4Bip5C9EbHV21h1AVHsVpFkOCRAAmFLAGK/y1GJfQlL7FbLi+E5z0RZdQFR7FaRZDgkQAJhSaCiskqmrcuUm/otNard7x6yQmZtOmQzqpw7QmJVvHNpucMv2tex6gKi2K0iyXBIgATCksCS1GNqkJnLe5wbBhZDwt46MF6u6b3EkL070qHYKXZ30omzday6gCh2q0gyHBIggbAk0Gthqpil7uym6858ip1idyedOFvHqguIYreKJMMhARIISwLd5qd4VCp3dlPGfIqdYq8vfbhaZtUFRLFbRZLhkAAJhCUBip0ydiXcQC236gKi2K0iyXBIgATCkoCVYk9Iypfh5AAAIABJREFUPyn3Dj030E2ghMD9REbmxKoLiGK3iiTDIQESCEsCVor943kpcqOpdz2FGxnCDdR5tOoCotitIslwSIAEwpKAlWIPlAC4n8jMMFh1AVHsVpFkOCRAAmFJgGKPTEmGY+bHqguIYreKJMMhARIISwIUO8UeKpkAqy4git0qkgyHBEggLAlQ7BQ7xR5ml+7Zs2elUaNGkpmZGWZHzsMlARKwJ1BdXW0/y+vfOiyKnWKn2L2+jIKzIcUeHO7cKwlYSaCqulo++mG7vPP9Fikpr/Qp6NNny6TXwh3Sc+EOyS8uF4qdYqfYfbqkAr8xxR545twjCVhNoKKqWo0O98CIBFmXkeNT8BknClVYjYevlCWp2RR7d4qdYvfpkgr8xhR74JlzjyRgNQGz2NdaKPbY1GMUO8Vu2ZDCvmYQrLpu2HnOKpIMhwRIwG8E/CH2+4etlNgdFLuvMuL21tV4WHUBUexWkWQ4JEACfiPgL7HHUOwhU1plBmGxZdcPxW4ZSgZEAiTgLwJa7PcNXSHxacfd3g06x2H9zNwi0R3qdRs7Suw/bT8qH/6wnXJjdXxIpAG3E7aLFSl2F4C4mARIIPgEtNiv7r1EPlu8y+0DmrzmgDw4IkHenJ4kZ8tqetObxT48bre0mrg+JG7qLLFaV6UdrizdTtguVqTYXQDiYhIggeAT0GLHDbvL7K1uHxAea8M2V/aKlYLicrWdWezvzdmmxB+uIuBxR1ZmwO2E7WJFit0FIC4mARIIPgFfxQ4Boloek1ns787aKnjsjYKMLEGG6/m06kqj2K0iyXBIgAT8RoBip3jDVdaeHLdVFxDFbhVJhkMCJOA1gcqqatUGDoFjZLnyyiqbsLwRe1lFleD96PrGihJ7UWmF7DpWoObdN2ylvDtrC0vs7DhnpBGdVoL1aZPoffhBsfsAj5uSAAlYQ2DVnpPyeXy6xKdly4SEDMEgNJC5nsxiR0e4MyU11ep6uf1ncVml4FG2ZqNXGzftg7lFMihml3y5fK9J7KyKD5bEuN+6tTD26djb3xS7t+S4HQmQgGUE8OjZVZ/Eym0DlynpotNbTmGpEb5Z7I9+kSjr9+Uayxx92Z19RtpO3mhIHRKZvj7T5jf2yTb2unKhcIPHxFFa9mZeSIi9srJS0tPTZc6cOTJu3DhZunSpFBYWGvHBW5hWrVolEyZMkK+//lo2b94spaXnLnpjRQdfOKSsAyicRQIhRsBeJu/N3ipH8oqNozSLvfHwBDXGu7HQwZcth07Lk2PX2oh8RNxum981VfEssduz52+K3cEl5fksSBpS79ixo9x3333y6quvypEjR4yAli9fLg8//LC89957ap22bdsq0evXLhorOvhCsTuAwlkkEGIE7GUSSLE/MDzBRvj2x8LfwRNdtLG36rIMmRJ7VlaWKrX37dvXRuyQd+PGjaVr166SnZ0t+/fvl3feeUc+/vhjyc2tvzoOkCh2q5IKwyEB/xGwv4FT7JSpfZqIht9WXWEhIXZzZEaNGmUjdsj8t7/9rWzYsEGtBtF/++230qZNG0lLSzNv6vA7xe4QC2eSQNAIlFZUStaps1JcVmEcg/1N+/VpSZKUeUrQsx1TfVXxZ0oq5EBOkVoPneoO5RZJ8sG6VfEjl6bblMxv6Bsnz3+1XtDWbr9//mbGIhhpwLggfPwS8mLfunWr/OpXv1KldR3XRYsWyfPPP6/a2vU8/VlVVSUlJSWqjR7t9CdOnJDrr79eMjMz9Sr8JAESCCKBrxP3yz1DVsj3Gw8a4ra/iWLo2FsHxsum/acEmfn6xP7ylE3y78+WSXp2gbw4aYO0nLBOvl69v04bu73YL+uxWBr2ipUGPWModj7yFhJpwKrLMuTFnpSUpMQOQevpp59+cip2CLxly5ZqG2QI8HfeeedR7BoeP0kgyATwyBlE/taMZGM0OHux69/zkw9LRWX9Yn9izBoV3tR1Nb3eURJvP3WTS7HrffCTpfNQSQNWXZohL3Z0ojv//PNl27ZtKs7Ivc+YMUNat24tqampdTigxF5cXCxnzpxRfyyx10HEGSQQVAKf1Yq9w/Qka8W+lmIPFUHxOLzLLFl1YYaM2CsqKlRHt2HDhkm7du0kIyNDPdIGkd9yyy3Sr18/yc/PFxxwt27dpEuXLqqa3RUItrG7IsTlJBBYAhS7dzd9yjLyuVl1JYaE2PEcO0rkI0eOlBYtWsjtt98uffr0kQULFqj2cnzef//9MnDgQOnRo4eqao+NjRWUzl1NFLsrQlxOAtYTqNIvP3cQtBY7RpDTL2ZxJq36quKxD+zGqIqvLbFf3zdO0O7evLaKXoc9JNb2OXY9n5+RL8xwOccOLhevZoWE2FFaX7NmjXpOHc+q679JkyapUjxK7QsXLpSePXvKp59+KsuWLVPV7e7EmGJ3hxLXIQHrCKCX+vwth2X1npNKvPYh+y72lfLVqn0yd3OWGvcdI9Hhxj21VuwYwa7JyFVy5+DlNh2iWk5cZ/M7XG72PM7oyXjYXyve/g4JsXt78O5sR7G7Q4nrkIB1BOJ2Zsu9Q1fIw6NWCV7uYj9psb/xnXcl9vuGrpA232yURv2WyoBf0tS+zGKnCKNHhJF2ru2vFW9/U+zekuN2JEACDglMXLVPbuy3VJWO8Zia/eSr2O8eskIe+aLm5S4dpicb48vrEnuk3ewZn+jJqNhfK97+pti9JcftSIAEHBKg2KNHRMx0WHuuHV5QXsyk2L2Axk1IgAScE7BS7Au21H2OnSV2a2VCOYcOT+dXlWdLKHbPeHFtEiABFwTcF/tmr3rFK7HXvmedVfGhIyVmEHw/Fy4uLbcXU+xuo+KKJEACZgLLd52QZ8evU2O6m+e7K/bXp3kr9uXyCMXOHv4ROAyu+Try5TvF7gs9bksCUUwAj5WhlNZi3FobCngUzZ3Oc+6IfZ4aUrbKZqz4uwcvl2Za7DPYeY4lZd9LyqHC0OZC8uEHxe4DPG5KAtFMQIv98S8TbTC4K/bXvt0seWfL1bbObqxOxT6qtle8Sezf1j7H7iwszo8cAUbqubS5kHz4QbH7AI+bkkA0E6hP7De58bibt2K/CyV2ip1V8ayKd3r7odidouECEiCB+gg4E/ukVfvESrGXV9pWxUPsD1PsFDvF7vTypNidouECEnBMoLC0QhL3npQDOUVS35jojreOnLla7Hi3+srdJ4we7vZix3ju+3OK5JMfU2XcygzpPHOLktKr324WPM6243C+U0n1WZQq4xMypMvsbcY61/ReIo36xqnfdw9ZLvo4nhxb8/rWSK2mZbwivynBqrsDxW4VSYYTNQTmbM6SpiNXyVvTkyWnsDRq4m0fUS3UK3vFSOPhK+Wr1fvUKpNW75eb+p8bee5sWaX0/WmnXNkrVg0DqzvW3Tloudyjhp6taS93JK6b+8cbHfEcLee8yJddNJ1j+2vM298Uu7fkuF3UEhixNF0u675YUHI8mHs2ajlosesbL0rXmOzFnne2rM6b1rDN5T0oJc2On0wLSANWTRS7VSQZTtQQGBGXrqqBr+gZI5m5RVETb/uIOhP713Yl9tNny+TR2rHdKTAKjGnAeRqwv8a8/U2xe0uO20UtAYq95tQ7FXuibVU8xP5Y7atVeVN3flMnG7Kx6qZKsVtFUkTKKqqkqLTCwhAZlBUE0MGtuKxSnR8rwguG2NFOXVpR5fTwsQzr2L9LDWkScUcHNmcTep0XFJcL3qPu6DWrzrazF3vPhTvUQDJfm8ReUl4pEDuedae4KC6mgfrTgLNrzdP5FLunxOpZPzY1W/X6pdzrgRSERcfySwSyWb3npFRUOpeju4cWaLGjF/536zNl+vqDDg8RMo7ZcUy1bUPiekI6XJKaLd+uy5Qjp4v1bJtPbJt88LQMid0ln8fvUX0G6skD2GxrL/ZWE9dLyuF8+XzpHrnu05pe6/OTD1PsEfhYFgVdv6C95WNzgfnwg2L3AZ79pi9+vUGVSlIO59kv4u8gElibkaPOy4c/bLekF3ugxZ6UeVr1OsfNwtGEkna7yZtUHI8XlBir7D5WoKrAr+uzRBZuOWLMN3/JLy6XwTG7jNJ0bOoxqXLwDnXzNvq7vdhxfBMS9sl7pkfTGvaKFXSee4IldoOxtzd9bucfmYYSV31t+fpJsftK0LS9FvuqPSdMc/k12AS02DvN3CKHT/veiz3QYl+6M1swPjpuQI6mU0Vl0vqbmkzlsfxzJfOkg6ekUb+akvP3Gw852lROnCmVHgtSDOn8sv2o29Xx7ogdx+ysV3wo3VB5LJEvzXA4xw4vUi9mUuxeQHO2iSH2dIrdGaNgzDeLPSuqxH7aeAbcXbEv3nHMD2IvlyfHcPCYcBALjzG4GRyr7o8Uu1UkRYRitxCmhUHZiP1UNJXY3RN79/nnSuyxfhJ7C44KZ9SKUJ7BlWco87fqtkexW0XSJPaE3bYl9rNlFVJYUlFvz2QLD4NB2RE4J/ZkyTp1Vk4XlTntIY/zhM5qp4pKVS/zXNPIcuhdj2X9f05TN2lPn2PH9th3RZVnHfjMVfFo/z55plQNZYtjQWc5c1X80bxiyc4vkerqakk6eE7sMzccVG3neluN6PDpYkEThb7Zzdp0SNCTHVX0lbXHiXb4fScL5Uht2Plny+VQ7llpWPvaVr0tPofHpUuHGclGeJi3af8po+bAvC6/U3BMA7ZpQF+Xvn5S7L4SNG2vS+xmseMGiTGym49Zo3ofm1bn1wARMIv9x61HBGOKv/39FiUw8yHsP1koHWckqxHlMKrcNX2WqO/IDGDanHlK7hu2UiB0fUPKzHF/gJqNtYIbuHiXebcuv8ftzBa8+AT77L0oVX0fFpcuN/SNE4QFmes29pFL01WPdIz+ZhZ7ywnrBJ0Hb/9smcxLzlL7RKe7YUt2SwNTfNDZ7d8D41Xc3521VfafLJI7Bi2Xq3svMf7ABr81A/PnFb1ibMLDMkdt8eZt+N325k4e0cvD5c3AzRUodjdBubOaFjteiKGnjQdOqfGwcbH+tP2ons3PABLQYoe0O81INkqaeHbbPEH6kJb9jRWlXUwrdp+os8wTsQ/4paakj+PwZDKLHcd2eY8Y43Gyt2Yky/asPEPs+tgfGJGgMpL6LWt6Pj6bjkxQu8dwuHcMWlYnTnrdRv2WSnr2GafL9Xr8jF4R8dxbe+49uS/Uty7FXh8dD5dR7B4CC9DqZrF3nplslCDDWezX9qnJgEDs2w7lyUu1j1rqG219Yn+IYmdmhc/Wh2QasOqWSLFbRdLUxs4Su4VQLQjKVuxbPBf7xuCW2NHGrqviIW6U2K0S++0ssYfkDV5n0PhpbYk41HlacLtTQVDsVpE0iR1VtnpiVbwmEbxPs9jRtn51bacv+xL7QmdV8RaLHaVsTyZz5zlD7LVNBnh17FanJfZT4qgq/lyJvUi1uTu72TXqu1R2ZxdQfCzdMg0EKA14cl+ob12KvT46TpZhbO1fUo7J8l3HVe9kvZquil+x64TsOJIvszcdEgwzi3dO4+Y5f8thm/UxvOm6jBz5fGm64DEjjPXt7YSezOv35UpcaragF3Mwp4rKmmFKEa9fUo6q4zlTUi4zNhyULYdOOz009LyeuvaA6vUN6X6xbK+gfRudwxA/DJu6as9JAX/Uiny79oD8kJwlELejsdDR+/yHpCwZumS34t/081Xy8KjVRuc37AM91bceOq2GU31zepKxzCy7DtOTVU9zR23sON5R8XvUOcSQrF8s3ys/bz8qS1KPCZ4Jx7lYtuu4Cv/pcWuN4wAbrL/n+BnFA3FS85amC545x3aIY0L6CUGGQw9Qg+PCK2PRSQ3fHxq5Sj6elyL3DV2pfuvjxvvQP/phu1zdO9ZmPpbjHefYF16zqkv+ejvzJzq9Yfx38zx+j64SJM93YM+305ujhwsodg+BYfWCknJ1I20/dZOSjg5Ci335rhPScuI6VRp6fVqSIfZBMbvUKFx6fTz6pN969egXibJuX45e5PHn7uwz6kUbDwxPUCLxOAALN4CIX55SM8TpvUNXyJq9OTJnc5bi8dS4tU73BImgp3e/n3fKpgOnpEGPGCWhaesyFRv0ZoeY8VKR/3y+Shr1jVNhvj9nm+SdrZuZOVFQopbfMiDeoZwgdmQYnh5fI1xnNzFItM+inQ47z6GK/DLTe8VRTY44PzB8pepBjwxeq4nrHO4f+1ucckzxQM2O3v/9w1YKercjjojvZzG7bKri9Xr8DOxNl7zJ299pwOnN0cMFFLuHwLA6JIITDNHsOlZghKDFjhIaluMxoruHrDDE3mX2VsELSfSEcb11QkEJCy/M8HYyi2F6bS9ub8Pydbu9x8/Y9LZetO2ooEf4VbWlR2fhPzO+RoB4dzd6gms2EBtK3ncOqnnkC89i62X4RCbCPJSqDv9ATpHNeuZt8B1ix4tS7Oc7+o2Ml6MSu6N1zfOQQcEjcuZ55u9a7POSsox1bh0YLy9MWm/87jp3G8UeoKpQ87nhd4o80GlA37t8/aTYvSCoxd587BpJcyT2tHNiR4lOV8XjuWCnYu+3VOZFiNhRvYznpfVFYYi9tm3bGXJD7KPrin1uUpZ6nhph2ou93RTbmhMdfmaudWJ/ZPRqv4odGRfN69YB8fLcVxS75sFPCjZa0oC+d/n6SbF7QdAQ+5g1kna0bok93onY35m1xaZkaS6x36jEXjNwiBeHJKFUYnck9oGL04z2XmfxM4t9aZptid2V2DEqmv2E57TruyF4UmIPuNgnUuz1nTsuo+wjMQ3Y38O8/U2xe0FOi/3xLxNVx6uKqmrVCeuFSTVv2DKLHdXHqI5HIkRvaAxognZddNqyFzs6gjmasC62wfChGEYUHa1KK6rUJ+Zj/2axT1l7QC2r773a2B5hYVtXk94X1iyuPQ5HndUQDo4HzRO2JfYjqt1cj0BWWl6pXjSCcPE+cMQHf0/rqvjRq8Us9r4/7VTvItdh2pfE8Qw3MhN6iFUcA/7QJFDfxY/qe/M5qG9dtHWj81596zhalpB+0qixcbQczS84bnQs1MvRue3ZCefa5d+ZtVXurB15Tq/DT4qNaSDy0oCre7G7yyl2d0mZ1oNEcFGhoxdkvjjlqKzJyJEmIxPU/PidNVXxji68Nt9slLaTN6rezmapoMTuSOyQ+paDp9VQp0/UviFrzIq90m1+iupg9fq0zYI2dbPY8TjT+IQMp73j84rLVW9n9JhGpzbI1dmE3tl4SciYFRmCMe9RRYy+BXjXt/2EMcrf+C5JhsTushH7pNX71JC6mgdGXsOwpui1jR7kGNYUx/vgiBp+aM+ON5XY9XbufKIjHPh2mJ7kslPc5aZOb+6EzXUi70bKc8pzGkppwP6e6u1vit0LcnjRhTkxdF+QImjn1fPqE7teB+2o7ogdnbsGx+wywtbbmz/Ri9osdr3M3ExgjubK9BOCR7+wHkrBKDE6m/AM9W0Da9rLIXkddq+FO+psMnblXrUcLwfRpWusj9In4qu3NX9e12eJMTyqnv/o6NWiaz30PH7yBsw0wDQQ6Wmgzk3VyxkUuxfgUDVsTmB4uUbrbzYa8yBD83Jn3+uIPaluVTyk2/vH1HrD81TseLYe2+C48EITvAzE2YTx7fXjYq7EPqQ2A2Iv9majVwvGHXfGwX4+xc4buH2a4G+miWhIA87uw57Op9g9Jfb/1+/7syOx17SvI/GFk9hRHW2Z2GNrahYgdrwRTF+IzUZ5LvZltR0QdRj85I2daYBpINLTgBc6crgJxe4QS/0z+9W+j1snspoS+zmxm5/B1us4+jSX2FGixSNP9pO/S+wYXKU+saMNXFejuyqx6xHe7MX+8KhVnpXYv0gUip03cUfXDOcxXURyGrC//3v7m2L3kBw6s2FkMXPiQs939GTW8574MtH4ruc5+tQD2mAZqsR7LNiheo+/MnWzYFQ7/GFgl3tqe9U7CgPz8G5sjOhmvxyj3+lwzJ/ozW9+PWmbyRvVeh/M3a6GgMVxoHMbBk955/utxru30fFP7wPH/tniNJvwdfU+Rl/TPeCx/nWfxjkcqlWHZf95/adxNp3t7JfzN2/uTANMA5GYBjzUkdPVKXanaBwvGLsiw5Cb1QkLQoOkzeFeU/t6TvM8f32/sles/PuzZep95Sil4zsyABib3H6f6FFvzhzYL+fvuszIhEyYBpgGnKWBa3svcSwdL+ZS7B5Cwxjgzk4M5/OiZRpgGmAaYBrwJg1grAyrJordQ5KN6xn325uTyW14E2AaYBpgGmAawOiWVk0Uu4ckH6odRIUXIi9EpgGmAaYBpgGr0gDF7oGMz549K40aNZLMzEwPtnK+Kt5/bdWJZDi8KTANMA0wDTANIA1Q7M69W2eJ1WLXrw7lxciLkWmAaYBpgGnAqjSAETqtmlgV7yHJawPYS92qBMNwePNhGmAaYBoI7TQwbZ01tcpQGsVOsbNpwcHjfLwJhvZNMJzODwZswsuRzONAhNPxB+tYMbaH+Z0TwToO835RY/vk2LpjhpjXeeyLROn8/RaP76tHTtd99bSHejJWDxuxFxcXy7Rp06Rt27byyiuvyIIFC6SwsNCIiLMvVlfFs8TOG775IuZ3pgdXaQADNI1dmSGfuXiZk6twom05MkT/qX1ZVajE/ZHRidJl1tZ6pd1herJ8uy6z3nUcxSe7oMSZxjyeHxZir66ullmzZsldd90l48aNk2HDhsnDDz8sP//8s1RUOH+BCWhQ7LzxOrqIOI/pIlBpgGL3Lq1R7B773NggLMReVVUlTZs2lcGDB0tZWZmUlJRIt27dpFOnTqotwYiNgy8Uu3cXVaBuetwPz0+kpwGIfRxL7B6XYENR7I9+kShdZrPE7kC1ns9CNfzFF18siYmJxsYzZ86Uli1bSkZGhjEPXyorKyU/P19OnDih/g4ePCjXXnutZY+7XdcnzuMEGuk3LsaPco70NNCgZ4zghUnexPPGfkvl68T9MiR2t9dhYFhnR/t3NM+bYwzFbfC+ieZj1njF3F9c0H7ede42p8eE89RxRrKgI5z5GPD+jPoYYzleCmbVFBYl9sOHDyuxp6amGvFetGiRPP7447Jr1y5jHr5g3Y4dO0qDBg3U3+WXXy6/+c1vLBP7G9M2S+PhCfwjA6aBKEoDQ2N3S7spm7w6513nbpfcwjLZcSRfdaLz5v7x5Ng18ub0pDr7f9nLY/LmGNzZBs9iu7OeO+u0mrhe1mTkeBVe28kbpclI9+7TD4xIkEe/cO+4u81PkXnJhx0eE8LBMS/adlS2HDotr357zhV4A+gD9VwvfRalCt7kadUUFmLHQaLEvm3bNiPe6DzXvHlz2b17tzEPX9AeX1paKkVFReovJydHrr/+esvEbrMz/iABEiABEiCBECMQFmJHu3rDhg3lxx9/NPCNHz9eXnrpJZfCtrqN3TgAfiEBEiABEiCBECQQFmJHKbxDhw7qMTe0qaNKvk2bNjJgwADVnl4fV4q9PjpcRgIkQAIkEGkEwkLsgJ6UlCQvvPCCvPjii/Lcc88p0W/dulXQY76+iWKvjw6XkQAJkAAJRBqBsBE7nldPS0uT2NhYiYuLk71790p5ebnL80Gxu0TEFUiABEiABCKIQNiI3VvmFLu35LgdCZAACZBAOBKg2MPxrPGYSYAESIAESMAJAYrdCRjOJgESIAESIIFwJECxh+NZ4zGTAAmQAAmQgBMCFLsTMJxNAiRAAiRAAuFIgGIPx7PGYyYBEiABEiABJwQodidgOJsESIAESIAEwpEAxR6OZ43HTAIkQAIkQAJOCESN2PEWOLz+lX9kwDTANMA0wDQQyWngwIED6v0qeBmao+k8RzPDad6pU6fU290aNWok//73v/lHBkwDTANMA0wDEZ0GbrrpJrniiiskNzfXoa7DXuyVlZWyc+dO9d729PR08fUvOTlZ/vSnP8mWLVt8DsvXYwn09nhF7uzZs+Xee++V7du3R1X8MZzxF198Ic8++6zs2LEjquKOdIYXL7322mvSr18/dT0FOu0Fc38pKSnqFdETJkyw7D4SzPh4um+8k+PSSy+VtWvXRl26x33+wgsvFNz3PeUWzPVRQ437FPznaAp7sTuKlC/zzpw5IxdddJF617sv4YTjtnjL3vr16+WRRx6RkpKScIyC18eMC+SHH35QcistLfU6nHDdEK9O/vjjj+Wrr74SvLchmiac79atW8vPP//s8qVTkcgFw3JfeeWVcuLEiUiMXr1xKiwslN/97neC+34kTRS73dmk2Cl2ip1it7stRPRPip1ij+gEjsghB3fDDTcIEnu0TSixo0qqTZs2Em1yw+uBFy9eLB999JGg9BptE96k+Nlnn8mMGTOcVu9FKhOc73fffVeWLVsWlSV2dDK7//77JScnJ1JPsdN4ofNZw4YNI66GliV2u1OOashFixZFXXWkxoDOGImJiVF3c0em5vDhw5KUlBSVN3dkbNDWvH//fgGLaJoQ940bN8rRo0ejLu44z2iGwuuyoy0zj7jjfr9gwYKIu99T7NF0B2NcSYAESIAEIp4AxR7xp5gRJAESIAESiCYCFHs0nW3GlQRIgARIIOIJUOwRf4oZQRIgARIggWgiQLHbne3vv/9e7rrrLtUzHj2k0aEq3CZ0BHriiSfUoBMYeAJ/jz/+uIoGOgpt2LBBWrVqJdddd50899xzalAO3WEKvaNXrFghjz76qBrR780331QdqjQDLF+4cKHqRXvjjTdK9+7d5dChQ3pxUD4LCgpk+vTpKs5XX321jBw5Uj3doA8GvX1xLnG8DzzwgMybN08NPayXHzt2TF599VXF47HHHpMlS5bYdKbBQBRPPfWUXHPNNYrbmjVr9Kbqc+XKlfLQQw8J9v3yyy+rwV5sVvDjD8QNA6s0a9ZMPYs8ZcoU49gxnjSecNBpAJ9IF+gkhgnnHHHDM9xIC88884ysW7fOpuMknpJA2sHy9u2Lo9L2AAAUA0lEQVTbCwYzMU8xMTHSuHFjlVbefvtt2bt3r3mxX7/j2Dp16iS33XabYCSuV155RTDUpp7QKSw+Pl4NPnPttddK27Zt5ciRI3qxGqvhxx9/VOcOT8J06dJFTp48aSxHj+lp06bJ3XffLbfccosMHDjQZjl6k48YMUJuvfVWueOOO2T8+PGSl5dnbO/vL7/88ou89NJLij0Y4FpEWtYTxiTAiJz6/GOkMgzCpCdcN19++aXcfvvtil///v1tzj3SD56UQNwRv8mTJ9t0LMV1b76ufvrpp4A9UYK4N2/eXHBece7xVAMG2MKEDnFTp05VA23hmsV5PX36tI62IN5jxoxxO97ffPNNyMTbiISLLxS7CRB6hmLUue+++04SEhJUwuncuXPYPfq2atUqdezo3Y+bOP70oywYYQ0XBC4E3MRxM8RIc3pAGlwcGJq3d+/esnr1aiU0rKOHLsTN9F//+pe6QcTFxSmh9OzZ0+bCMSENyFccG27AY8eOVceDY8fFi0kPvHLffffJ8uXLZfTo0UoEyLzozAwyMRAeeAwYMEAefPBB9WQAtsfjj4gvMjibN2+Wbt26qQF8MDIfJozYdskll8iQIUPUo4Kvv/66IHNgvsGqFf30D6KaNGmS+oNgcONG5gsTzjtu/Lg5m9OBHq0K4nr44YeV/BH3rl27Kn5II5gwpgOk8MEHHyg2YPD8889LRkaGWo5Ru377298qOeBJCiyD/HVaUyv58R9GSfzkk08EGa1t27ZJy5Yt1Y0ewsWEOP3nP/+RTz/9VA289PTTT6u0jmU497hO7rzzTiVnZM6Q6UPmBPx0T/Hrr79ecGOHtLAuMo06/K+//lquuuoqldHFY4JYjnSo+fsx6iroPn36qPSMuG/atEmaNm2qzrfu3T58+HCVaUNaxflHmkR61vGH3HBdzJ07V3At/9///Z9KK1iOx32Rpps0aaLijozz3//+d0FGDhOG8sa1gGsHjwkig4PHxvR1oVby4z+cOzyeiowp4o7MKQopGGRn5syZ6hrHfRzXLApq7dq1U0eD8454456HeC9dulT+8Y9/OIw37p84rxdffLHaV33xxjkIpYliN50NlFjee+89Yw5EgIRrX0IzVgjRL0j0Tz75pLogs7Oz1UWIGxX+UFpFnPbs2aOOHhc8LkgkcNyQkOghJn0DwA0bwsCwvZhw48NFpCdcHJAihjcMhemtt95SmRItdpSgUNrERYoJNz0IqkePHpKfn6+O+89//rMND5TsPv/8c5XZwY0aF76+WSPj8+KLL6oR2nCT6NWrlxqGVssSQz2ihDtr1qyA48B+HYl90KBBgnSADJD5GX2ka4hJl3LxiVEHceyILzJKYKdHosMNtEWLFgZLsMYQvHpCRhDpDjUewZhQ2sYoYshwIJ5Iy6ix0DVK+ETGHcJH+ujbt68aaVCPWQG5NWjQQHFCpueNN95QmR0dF5SAce1AkDj3EDkyipjwG5yRCc7KytKbBOwT+8eQsCh961oTiB3xx2OMEB4yalgP08GDB1UmALUMOm1D3sjEIuOC6x0ZNZR89YTSOWqmMCHzh0whajwwIVzUAkL2gZ5QC4lzh3ODkTORuUTtgx5NDtLFyHrIhOt4jxs3zibeyMB6G29kKDBqo2Yb6Pg72h/FXksFJVZU28yfP9/ghAsCN/E5c+YY88LhCxI3brjIlSLHje/IVeNmhpsPEr75Bo8LFKU6JOx33nnHJnODnPk999yjnvVEwsVAFvpmBhaomkUJN1QyP/Zix00eVZC4oPWEUheqzCE7VF3jotcT4oiSEGo0cDN8//331Q1LL4ccUbLFOkgzKAWCHW4umJBR6tChgyrt6G0C9WkvdlSlIp6oRtXpAGlZiwyZAFSj6wlxwHjxEB4ydijl4LeeIDSIAlX/kAHChTz1hEwPMkVmGehlgfhEhvZvf/ubEqs+T6hN0uLCMaA5BvHGuYe4Bw8ebBwaMgYQOzKzyBCiBGyOC8R58803q6YpMPzLX/5ik+4xJDGuNV3jYQQcgC/IWKKEimtZNyfgPKEWAvcBzEfto5Y+MmkQEqq09YTan//+7/9WAsT1jIIOarb0BIkjY4R9YTnC1Rl+rIMSPmoDAyU43K9QIkcBDNXtuFYxDgUKJjhWfU1C8KiFRKFGxxvDB+sJ8UbmHuJ3FG8UCrDcWbyHDh0a0Hjr467vk2KvpYMbAW7w5oSM0hduZN9++219DENuGW5aSMCopkJJGjc33LAgYXyH/MwTLvAPP/xQ3fAhfVRl6wkZANz8dfsa2uzMNzvczCF2ZBwCdUHrY3P0aS92HBdKpcig6GnixImqNIILGlWIuOjNEzI/kDOWowSGEr6ecJNA9S94IaOEEgzaKXXckRlA5sjMUG/r7097sUM+KJ3ihgXZIK4o0aEPBo4XAseN2Dzh2FH6QG0GamIQTz2BIWSIkiDCRk0Pqir1hMFtkJFAKTDQE65V9DNATQwmZEI6duyomlbMxwLRId44t8iEQPJ6Qm0O7gG4kaNNFlW4kIGeUM2M9A+WyMBB7OaaKlQNgxkKBIGe0G8G8katgp5wnLgPoCYGwkJtywsvvKAypMi84LpHHwQ94ZxC3MjA4D6I2hcUEvSE5snzzz9fjdKGZkuw1LU9WAfnHRl/fS3o7fz1iRoYxAmZVtQ0oVCGpkJwQA2knpBJxT0KmXgdb/NyK+KNe6TOSOj9BvOTYq+ljxs2BICLU0+4IaLaGW024TwhZ4sbFkpXeHsX2oF11THihZs7SqBI4BAabux6Ahe0w6FTIRIuSmkoCegJNzZcNCgtBeqC1vt29GkvdogNcceNXk8QMTJsmIebETpO6QlxQDUeSjfIIKFzFgSgJ5TkwAcCQXUtSgcQnb6osY0joejt/flpL3b7feEGhxsg0gGq11HSQBu0nhB3nH80LyDTghs/4q8nZFqQ8QM/SBClX7Qz6wmlQZTyzfP0Mn9+Ig1iv2hGQ4YEE44VtS5I1+a0jvSLeOPco8Mkzp2esC1qdyA7nGfcrM3XPiSJjlqIJ8QPsaPEqCd0KkUnS9w3AjlB2kiHyJDqJjRH+0eGDvFDHwkIG+cXgtYTCjcomUKOun8NPvWEddHUgcw++iTgvqCb9LAOmq8g1UDdB3BeUTuB+GDfqF1FrQnSOGoi9HGACWodcQ/T8dZ9BXDciDcyNM7ijaal3//+907jPWrUKJWp1PvTvIL5SbHX0seNGTk/c9Uccq64UM25u2CeLG/3jQsRmRa0mSLXiio2lDgw4WaG6kW0q+JmjWpl5OrxHRNumijl/b/27mc1iiAIA7gXL8ZLJBAEEXwL30E9CPHmQQ8GckrewHMuPoEnQR8gLyAhpwiBXHIL+Cgrv4YKzZLETZjs7J+vYdw1PTPb9XVNf1XVPV0eCIrL0BH2qkLpzW0JeS9CmSZ2bzVYrc5SVxAaLxQJ8EB5IcK3wtaKAR0x1xydaQf4FHH//fu3EYKH2cBizQGPvuovLy/bgGnB1bzL/4idgYcADIJwsCAMOddiN4Mk3eD16X9GYO+JCLtaoGbRGnkRAwOoCpIzz4rg5lXMn4qqWBGOzKswUj3LDJWST38/f/68ZXFDzAw0elDTUsK4IlsiDwxaCw8tpqxiPQkjlk7peyuy+4iF54sR6Pp5FZ41ImOsaPNtxTNKPtEN0TxEaA0JWRTRLfjQA9E9/YsoqzCC6IsCd+NlRTiNDZ49xxgEh5R578Y34xfjlb4r+kNfGc9vktsCuZvkFuli0N0kt/FiLLlbo675J8TegWJBBcVlAQsxIwCegLDdMhVkjMi0G9EY4F68eNE8CVa7wZ3i8zwQlNdZDFYGa5436xbRewgMmOaRyxAQ7rKYjrHDM6HUvLqqHwMn7TZQm0dnePDUtM2Abh6cdy5KITQpImPulHwGdJ6pV4WEzln+PDT4CMe6Lz2weI4XaoBAeiIcNaDxYujM0dHRBOmbv2fozCsca1DmcZDdQGsFODn8zUDFcxGy1DaRFkYKY8bgq8+8ynV4eNh0Qb1wdhlx9MhiKuRFV5AHYi8jTphaPV3gucEQWTh3HkVoHJHqb22lAwxVc+rk09eMHXPPMEHSBngE7xykxcNk4OhnusywoTPq9TlMPROIjmw1TUE+URu6glSQhmuR3/8IdihsRBboMgPM88so9duMNtEkbYIRo1X7EZ6pAnUOuuJ5Ecb3vNBbUQx6T3cshPN/17oXA7/W19AdBi3DlsEHa88RLOdROBTarJ3GKRjoC1EVhqtpBFEFz6zpJcaPZ72Xm56X3IzD6+QW8RPlMU4qY8s9K7Yh9g4pAwMiM09kwDNoIMiyaLtTF/orUkI+QmXmgC3o8TcPvLBUkRcZDeTIumSk/MLTrkPwSN3ilFqAZPDg1fPk1JtTpfzuPVbRZoYKA2Vra6u9nsLCtp7AAI+IDMraa15QyFLIvIoBwIAHD6FpnpfBX4ELD9UAqt551lwYIBSeodC0+6oX4ZFUorzAdtID/oPARRfILpzIgEPe+giZ0QP6rH2IR9uLeMprNyCWLvDgqp7sPCC6oJ4u0JXyhOhS6YJ6xIHkS1ceUOx2a/PjT58+nbx69aqRjlXqZEXECl21noKOax/isnq6Cg+fUcMLpxuiDYiBzjgYxqYl3NNCMesLGGwIQGEs8dTUedY4Aowa186jGJ+8buiVPLI7RBm0kYFjMRu9rcVz2tq/jsYYsxC05GMAk0khI0Jn7JR8XnukbwrdQfaugZ3xwO/BfB7FngL60297ZhEzI5ZRZprFOhg6b52E8U+/ViE3We4id0V9bpIbdyxSCbFP9YZBzesqPCCdOSZhTTVt5v8iHZYlGXhrBrBejlJ+9R6CnoQMSsjKoKaetd8P1OoN6DyERcHIIOTBspCnP1jzCoLSl9qr3drfD76wIad6csOvr4dP4QmvIrbqEHi5r0GRwdDjWec81GfJ1svtO3n1W7W7+lLf90VbtVm9c6dlc37dw3k1RVP3gFXpAj3rdaXOeahPJDIttz7QH1V879vfPwfTukxf4FmFXjEajQeeI8ZeX+96eqfOOdpTpF/3eMhPOjstP/3VZ/VMaBdM9JG29u3zXZu1X/+XMVttJqu/lXyMhb7Asn+upp+b/tyhv5Olnjkylr77Hf1S/Ub26/q1l7uMlWrjXeWeHk/qPmN+htjHRD+/HQSCQBAIAkFgYARC7AMDmtsFgSAQBIJAEBgTgRD7mOjnt4NAEAgCQSAIDIxAiH1gQHO7IBAEgkAQCAJjIhBiHxP9/HYQCAJBIAgEgYERCLEPDGhuFwSCQBAIAkFgTARC7GOin98OAguMgFeIvPvsFb8hi/es7RUwr41shmx77hUElgGBEPsy9FLaGATuiYD3nO0OZhOW/uiTu9x0a++A2/TDe7pDFruGSQlq56+UIBAEhkcgxD48prljEFgYBGyZaect26naOrQO+4XPUvoNWWY5f5ZzQuyzoJRzgsD9EQix3x+7XBkEFh4BxG6bUdvi2pGrP+wkJimI7TntA247Wvu91459dhyTHMMWnHaU473bXtS2vZUt0P3sQGbPfPdQZ/912wyXUeBT1GB7e7ttAWpv995jtwOafejdUxISGeS0OyUIBIH7IRBivx9uuSoILAUCCNIe7hKa2DqzDmF222o+fvy4JTqRUEQ+AQkvnGvrWNuMbm5utiQb5sUlgJFQyB70kgnZFx6xS8Ihg549+O0vfnBw0BJy+LsiQYfUuHIOSJdp/3IJQyoUb49xvysvg2Qu9i+XfIlhkRIEgsDdEQix3x2zXBEElgYBxG5uXaIUWfnqkMkQsfOw+xSzPGcefu2dX8QuTadMYLLbIXzePlJXELPsWbVHvoxaEsdI3+pvfkNyGcU1379/bwk4ELv9xWWIk5iI8eDw3fRBnyu8XZx/gkAQmAmBEPtMMOWkILCcCCB2YW8pWa1ur0OyI8Qu/M6TrvLz58+WEa4SuxSxO9c95LyWApd3Ll0popYWUxawKpKQIGZZAq2sf/ToUfPwq15kQBY8xG5lPOKXHlWWOQcjQZsrS1tdl88gEARmQyDEPhtOOSsILCUCiL3m2KcFQNbm0KVirSLNqZA7A6APxas3zy4MLy2te0qbaf5calPh/ppTN0cvD/qPHz9aCtgnT560fN3uwRD49evXVd73mscXonddHaYMpjPJVRvzGQSCwO0IhNhvxye1QWCpEag5dnnYvbZWR82xb2xsTHZ3d9sCuTr369evLe1lT+wI14p6KTJ9//btW5s3R+ZynAvxW+3O05fD3QI68/CInKEgbzfv3Gr8vb29ttCOx85Y+PDhQwvzm1/n4Tvvz58/V4v4lroD0vggMAICIfYRQM9PBoF5IYCskezr169beFuI27G/v99C8c+ePZt8+fKlrUR/+/bt5OPHj5Ozs7OWt7sndivjLWrjqTvev3/fQu2IW+5rxsCbN28aiQuzC9tX/u7z8/MW3n/37t3k06dPV95+LZ5D6J8/f57s7Oy0tlk4d3h42CIG88IpvxMEVgmBEPsq9WZkCQJTCFicZi7cPHp/IFWh+JcvX7bX2HjXx8fHLdRei+DMlfsb795xcXExOTk5aXPfyN88vYLcedru8fv372YYuLe/Vz1P3Zz56elpW0XP4Cjid45IgFfkXK9tNtZJKL7Bl3+CwJ0RCLHfGbJcEARWAwHka0V6ec6rIVWkCAJBIMQeHQgCa4pAiH1NOz5irzwCIfaV7+IIGASCQBAIAuuEQIh9nXo7sgaBIBAEgsDKIxBiX/kujoBBIAgEgSCwTgiE2NeptyNrEAgCQSAIrDwCIfaV7+IIGASCQBAIAuuEQIh9nXo7sgaBIBAEgsDKI/APG6hnomsWZl0AAAAASUVORK5CYII=)

# Deep Q-Network for Atari Breakout.

In this assignment you are required to implement a Deep Q-Network agent, for the Atari game Breakout.

You need to submit your code, along with a plot of the rewards during training, and a video of an episode with the trained agent.

__Frameworks__ - we'll accept this homework in any deep learning framework. This particular notebook was designed for PyTorch, but you'll find it easy to adapt it to almost any Python-based deep learning framework.
"""

!pip install setuptools==65.5.0 "wheel<0.40.0"
!pip install stable-baselines3[extra] ale-py==0.7.4 gym==0.21.0
!pip install pyglet==1.5.27
!pip install pyvirtualdisplay

import os
import random
import numpy as np
import torch
import gym
import numpy as np
import matplotlib.pyplot as plt
from IPython import display as ipythondisplay
from pyvirtualdisplay import Display

if type(os.environ.get("DISPLAY")) is not str or len(os.environ.get("DISPLAY")) == 0:
    !apt-get -qq install -y xvfb
    os.environ['DISPLAY'] = ':1'

display = Display(visible=0, size=(400, 300))
display.start()

"""## Breakout

This is an environment emulating the Atari game *Breakout*. The goal is to break all the bricks in the wall without letting the ball touch the floor. You have 5 lives and get points more points for higher brick than for the lower ones.

The observation is an image with dimensions (210, 160, 3).

There are 4 actions defined as NOOP, FIRE, LEFT and RIGHT.

See full description [here](https://www.gymlibrary.dev/environments/atari/breakout/).



"""

ENV_NAME = "BreakoutNoFrameskip-v4"
env = gym.make(ENV_NAME)
obs = env.reset()

n_actions = env.action_space.n
obs_dim = obs.shape
print("observation dim", obs_dim, "number of actions", n_actions)


n_cols = 5
n_rows = 2
fig = plt.figure(figsize=(16, 9))

for row in range(n_rows):
    for col in range(n_cols):
        ax = fig.add_subplot(n_rows, n_cols, row * n_cols + col + 1)
        #ax.imshow(obs)
        ax.imshow(env.render('rgb_array'))
        env.step(env.action_space.sample())
plt.show()

"""## Wrappers

In order to make the environment more suitable for RL training, we make the following updates to the environment, using environment wrappers:
1. Preprocess the images to contain only the relevant part of the image, converted to grayscale. The raw images are large and we can do with 64x64 images.
2. Concatenate the 4 previous images (in order to capture dynamics)
3. Start the fire action automatically when starting the episode
4. Repeat the same action for 4 time steps
5. Output the maximum values of the last 2 frames per pixel (in order to prevent blinking)
6. Ouput a "done" signal every time a life is reduced but only reset the environment when all lives are gone
7. Bin the rewards to the values {-1, 0, 1}



"""

from gym.core import Wrapper
from gym.spaces.box import Box
from gym.core import ObservationWrapper
from gym.spaces import Box
import cv2

class PreprocessAtariObs(ObservationWrapper):
    def __init__(self, env):
        """A gym wrapper that crops, scales image into the desired shapes and grayscales it."""
        ObservationWrapper.__init__(self, env)

        self.img_size = (1, 84, 84)
        self.observation_space = Box(0.0, 1.0, self.img_size)


    def observation(self, img):
        """what happens to each observation"""

        #  * crop image, remove irrelevant parts
        #  * resize image to self.img_size
        #  * cast image to grayscale
        #  * convert image pixels to (0,1) range, float32 type
        img = img[34:-16, 8:-8, :]
        img = cv2.resize(img, self.img_size[1:])
        img = (img*np.array([[[0.8, .1, .1]]])).sum(-1, keepdims=True)  # grayscale with more weight for red (accelerates training)
        img = img.astype('float32') / 255.
        return img.transpose((2, 0, 1))

class MaxAndSkipEnv(gym.Wrapper):
    def __init__(self, env, skip=4):
        """Return only every `skip`-th frame"""
        gym.Wrapper.__init__(self, env)
        # most recent raw observations (for max pooling across time steps)
        self._obs_buffer = np.zeros(
            (2,) + env.observation_space.shape, dtype=np.uint8)
        self._skip = skip

    def step(self, action):
        """Repeat action, sum reward, and max over last observations."""
        total_reward = 0.0
        done = None
        for i in range(self._skip):
            obs, reward, done, info = self.env.step(action)
            if i == self._skip - 2:
                self._obs_buffer[0] = obs
            if i == self._skip - 1:
                self._obs_buffer[1] = obs
            total_reward += reward
            if done:
                break
        # Note that the observation on the done=True frame
        # doesn't matter
        max_frame = self._obs_buffer.max(axis=0)

        return max_frame, total_reward, done, info

    def reset(self, **kwargs):
        return self.env.reset(**kwargs)

class ClipRewardEnv(gym.RewardWrapper):
    def __init__(self, env):
        gym.RewardWrapper.__init__(self, env)

    def reward(self, reward):
        """Bin reward to {+1, 0, -1} by its sign."""
        return np.sign(reward)

class FireResetEnv(gym.Wrapper):
    def __init__(self, env):
        """Take action on reset for environments that are fixed until firing."""
        gym.Wrapper.__init__(self, env)
        assert env.unwrapped.get_action_meanings()[1] == 'FIRE'
        assert len(env.unwrapped.get_action_meanings()) >= 3

    def reset(self, **kwargs):
        self.env.reset(**kwargs)
        obs, _, done, _ = self.env.step(1)
        if done:
            self.env.reset(**kwargs)
        obs, _, done, _ = self.env.step(2)
        if done:
            self.env.reset(**kwargs)
        return obs

    def step(self, ac):
        return self.env.step(ac)

class EpisodicLifeEnv(gym.Wrapper):
    def __init__(self, env):
        """Make end-of-life == end-of-episode, but only reset on true game over.
        Done by DeepMind for the DQN and co. since it helps value estimation.
        """
        gym.Wrapper.__init__(self, env)
        self.lives = 0
        self.was_real_done = True

    def step(self, action):
        obs, reward, done, info = self.env.step(action)
        self.was_real_done = done
        # check current lives, make loss of life terminal,
        # then update lives to handle bonus lives
        lives = self.env.unwrapped.ale.lives()
        if lives < self.lives and lives > 0:
            # for Qbert sometimes we stay in lives == 0 condition for a few frames
            # so it's important to keep lives > 0, so that we only reset once
            # the environment advertises done.
            done = True
        self.lives = lives
        return obs, reward, done, info

    def reset(self, **kwargs):
        """Reset only when lives are exhausted.
        This way all states are still reachable even though lives are episodic,
        and the learner need not know about any of this behind-the-scenes.
        """
        if self.was_real_done:
            obs = self.env.reset(**kwargs)
        else:
            # no-op step to advance from terminal/lost life state
            obs, _, _, _ = self.env.step(0)
        self.lives = self.env.unwrapped.ale.lives()
        return obs

def PrimaryAtariWrap(env, clip_rewards=True):
    assert 'NoFrameskip' in env.spec.id

    # This wrapper holds the same action for <skip> frames and outputs
    # the maximal pixel value of 2 last frames (to handle blinking
    # in some envs)
    env = MaxAndSkipEnv(env, skip=4)

    # This wrapper sends done=True when each life is lost
    # (not all the 5 lives that are givern by the game rules).
    # It should make easier for the agent to understand that losing is bad.
    env = EpisodicLifeEnv(env)

    # This wrapper laucnhes the ball when an episode starts.
    # Without it the agent has to learn this action, too.
    # Actually it can but learning would take longer.
    env = FireResetEnv(env)

    # This wrapper transforms rewards to {-1, 0, 1} according to their sign
    if clip_rewards:
        env = ClipRewardEnv(env)

    # This wrapper preprocesses observations
    env = PreprocessAtariObs(env)
    return env

class FrameBuffer(Wrapper):
    def __init__(self, env, n_frames=4, dim_order='tensorflow'):
        """A gym wrapper that reshapes, crops and scales image into the desired shapes"""
        super(FrameBuffer, self).__init__(env)
        self.dim_order = dim_order
        if dim_order == 'tensorflow':
            height, width, n_channels = env.observation_space.shape
            obs_shape = [height, width, n_channels * n_frames]
        elif dim_order == 'pytorch':
            n_channels, height, width = env.observation_space.shape
            obs_shape = [n_channels * n_frames, height, width]
        else:
            raise ValueError(
                'dim_order should be "tensorflow" or "pytorch", got {}'.format(dim_order))
        self.observation_space = Box(0.0, 1.0, obs_shape)
        self.framebuffer = np.zeros(obs_shape, 'float32')

    def reset(self):
        """resets breakout, returns initial frames"""
        self.framebuffer = np.zeros_like(self.framebuffer)
        self.update_buffer(self.env.reset())
        return self.framebuffer

    def step(self, action):
        """plays breakout for 1 step, returns frame buffer"""
        new_img, reward, done, info = self.env.step(action)
        self.update_buffer(new_img)
        return self.framebuffer, reward, done, info

    def update_buffer(self, img):
        if self.dim_order == 'tensorflow':
            offset = self.env.observation_space.shape[-1]
            axis = -1
            cropped_framebuffer = self.framebuffer[:, :, :-offset]
        elif self.dim_order == 'pytorch':
            offset = self.env.observation_space.shape[0]
            axis = 0
            cropped_framebuffer = self.framebuffer[:-offset]
        self.framebuffer = np.concatenate(
            [img, cropped_framebuffer], axis=axis)


def make_env(clip_rewards=True, seed=None):
    env = gym.make(ENV_NAME)  # create raw env
    if seed is not None:
        env.seed(seed)
    env = PrimaryAtariWrap(env, clip_rewards)
    env = FrameBuffer(env, n_frames=4, dim_order='pytorch')
    return env

env = make_env()
env.reset()
n_actions = env.action_space.n
state_shape = env.observation_space.shape

"""## Check observations under wrappers"""

for _ in range(12):
    obs, _, _, _ = env.step(env.action_space.sample())

plt.figure(figsize=[12,10])
plt.title("Game image")
plt.imshow(env.render("rgb_array"))
plt.show()

plt.figure(figsize=[15,15])
plt.title("Agent observation (4 frames top to bottom)")
plt.imshow(obs.reshape([-1, state_shape[2]]), cmap='gray')
plt.show()

"""## Random Agent

Here we implement a random agent to use in the 'evaluate' function, that runs the agent through multiple epsiodes.
"""

class RandomAgent():
    def __init__(self, n_actions):
        self.n_actions = n_actions


    def get_qvalues(self, states):
        return np.random.normal(size=(1,self.n_actions,))

    def sample_actions(self, qvalues):
        return np.random.randint(self.n_actions, size=(1,))

def evaluate(env, agent, n_games=1, greedy=False, t_max=10000):
    """ Plays n_games full games. If greedy, picks actions as argmax(qvalues). Returns mean reward. """
    rewards = []
    for _ in range(n_games):
        s = env.reset()
        reward = 0
        for _ in range(t_max):
            qvalues = agent.get_qvalues([s])
            action = qvalues.argmax(axis=-1)[0] if greedy else agent.sample_actions(qvalues)[0]
            s, r, done, _ = env.step(action)
            reward += r
            if done:
              break

        rewards.append(reward)
    return np.mean(rewards)

agent = RandomAgent(n_actions)
mean_reward = evaluate(env, agent, greedy=True, n_games=5)

"""## Video generation"""

# run sessions

import gym.wrappers
import sys
from pathlib import Path
from base64 import b64encode
from IPython.display import HTML

n_games = 1 # how many games to record

with gym.wrappers.Monitor(make_env(), directory="videos", force=True) as env_monitor:
    env_monitor.reset()
    sessions = [evaluate(env_monitor, agent, n_games=3, greedy=False) for _ in range(10)]

# show video

video_paths = sorted([s for s in Path('videos').iterdir() if s.suffix == '.mp4'])
video_path = video_paths[-1]  # You can also try other indices (if n_games>1)

if 'google.colab' in sys.modules:
    # https://stackoverflow.com/a/57378660/1214547
    with video_path.open('rb') as fp:
        mp4 = fp.read()
    data_url = 'data:video/mp4;base64,' + b64encode(mp4).decode()
else:
    data_url = str(video_path)

HTML("""
<video width="640" height="480" controls>
  <source src="{}" type="video/mp4">
</video>
""".format(data_url))

"""## Assignment

Implement a DQN agent that contains:
1. A neural network that predicts the q-values for a given observation.
2. An experience replay buffer where all transitions are added.
3. A target Q-network that is formed by periodically copying the weights of the main Q-nework.

You will also need to implement the training loop, and submit a figure showing the reward as a function of the training step, and a video showing an episode with the trained agent.
"""

from google.colab import drive

drive.mount('/content/drive')

import os
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import gym
from gym.wrappers import AtariPreprocessing, FrameStack

# Set device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Create the environment


class ReplayBuffer:
    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = []

    def push(self, state, action, reward, next_state, done):
        if len(self.buffer) >= self.capacity:
            self.buffer.pop(0)
        self.buffer.append((state, action, reward, next_state, done))

    def sample(self, batch_size):
        batch = random.sample(self.buffer, batch_size)
        state, action, reward, next_state, done = zip(*batch)
        return np.array(state), action, reward, np.array(next_state), done
    def __len__(self):
        return len(self.buffer)

class QNetwork(nn.Module):
    def __init__(self, n_actions):
        super(QNetwork, self).__init__()
        self.conv1 = nn.Conv2d(env.observation_space.shape[0], 32, kernel_size=8, stride=4)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=4, stride=2)
        self.conv3 = nn.Conv2d(64, 64, kernel_size=3, stride=1)
        self.fc4 = nn.Linear(self.feature_size(env.observation_space.shape), 512)
        self.fc5 = nn.Linear(512, n_actions)

    def forward(self, x):
        x = nn.functional.relu(self.conv1(x))
        x = nn.functional.relu(self.conv2(x))
        x = nn.functional.relu(self.conv3(x))
        x = nn.functional.relu(self.fc4(x.view(x.size(0), -1)))
        return self.fc5(x)

    def feature_size(self, input_shape):
        return self.conv3(self.conv2(self.conv1(torch.zeros(1, *input_shape)))) \
            .view(1, -1).size(1)


class DQNAgent():
    def __init__(
        self,
        env,
        seed=42,
        gamma=0.99,
        epsilon=1.0,
        epsilon_min=0.1,
        epsilon_max=1.0,
        epsilon_interval=0.9,
        batch_size=32,
        max_steps_per_episode=10000,
        max_episodes=10,
        lr=0.00025,
        begining_frames_exploration=50000,
        update_target_freq = 10000,
        replay_buffer_capacity=10000

    ):
        self.env = env
        self.num_actions = self.env.action_space.n
        self.replay_buffer = ReplayBuffer(replay_buffer_capacity)

        self.model = QNetwork(self.num_actions).to(device)
        self.model_target = QNetwork(self.num_actions).to(device)
        self.model_target.load_state_dict(self.model.state_dict())
        self.model_target.eval()

        self.optimizer = optim.Adam(self.model.parameters(), lr=lr)
        self.loss_function = nn.HuberLoss()

        self.seed = seed
        self.gamma = gamma
        self.epsilon = epsilon
        self.epsilon_min = epsilon_min
        self.epsilon_max = epsilon_max
        self.epsilon_interval = epsilon_interval
        self.batch_size = batch_size
        self.max_steps_per_episode = max_steps_per_episode
        self.max_episodes = max_episodes
        self.begining_frames_exploration= begining_frames_exploration
        self.update_target_freq=update_target_freq
        self.running_reward = 0
        self.episode_reward_history = []
        self.frame_count = 0

    def epsilon_greedy_action(self, state):
        if self.frame_count < self.begining_frames_exploration or self.epsilon > np.random.rand(1)[0]:
            return np.random.choice(self.num_actions)
        else:
            state_tensor = torch.FloatTensor(state).unsqueeze(0).to(device)
            action_probs = self.model(state_tensor)
            return torch.argmax(action_probs).item()

    def update_target_network(self):
        if self.frame_count % self.update_target_freq == 0:
            self.model_target.load_state_dict(self.model.state_dict())

    def train_step(self):
        state, action, reward, next_state, done = self.replay_buffer.sample(self.batch_size)
        state_sample = torch.FloatTensor(state).to(device)
        state_next_sample = torch.FloatTensor(next_state).to(device)

        action_sample = torch.LongTensor(action).to(device)
        rewards_sample = torch.FloatTensor(reward).unsqueeze(1).to(device)
        done_sample = torch.FloatTensor(done).unsqueeze(1).to(device)

        q_values = self.model(state_sample)
        next_q_values = self.model_target(state_next_sample)
        updated_q_values = rewards_sample + self.gamma * torch.max(next_q_values, dim=1)[0].unsqueeze(1) * (1 - done_sample)
        q_action = q_values.gather(1, action_sample.unsqueeze(1))
        loss = self.loss_function(q_action, updated_q_values)

        if self.frame_count % self.update_target_freq == 0:
            print(f"loss: {loss:.4f}")
        self.optimizer.zero_grad()
        loss.backward()
        self.optimizer.step()

    def train(self):
        while True:
            observation = self.env.reset()
            state = np.array(observation)
            episode_reward = 0

            for timestep in range(1, self.max_steps_per_episode):
                self.frame_count += 1
                action = self.epsilon_greedy_action(state)
                self.epsilon -= (self.epsilon_interval / 1000000 )
                self.epsilon = max(self.epsilon, self.epsilon_min)
                state_next, reward, done, _ = self.env.step(action)
                state_next = np.array(state_next)
                episode_reward += reward
                self.replay_buffer.push(state, action, reward, state_next, done)
                state = state_next
                if self.frame_count % 4 == 0 and len(self.replay_buffer.buffer) > self.batch_size:
                    self.train_step()
                self.update_target_network()
                if done:
                    break
            self.episode_reward_history.append(episode_reward)
            if len(self.episode_reward_history)%1000 == 0:
                plt.plot(self.episode_reward_history)
                plt.xlabel("Episode")
                plt.ylabel("Reward")
                plt.title("Reward per Episode")
                plt.show()
            if len(self.episode_reward_history)%1000 == 0:
                torch.save(self.model.state_dict(), os.path.join("/content/drive/MyDrive/Colab/", f"dql_model_{len(self.episode_reward_history)}"))
                torch.save(self.model_target.state_dict(), os.path.join("/content/drive/MyDrive/Colab/", f"dql_model_target_{len(self.episode_reward_history)}"))
            self.running_reward = np.mean(self.episode_reward_history)
            print(f"Episode {len(self.episode_reward_history)}: Total Reward: {episode_reward}, Epsilon: {self.epsilon},frame_count: {self.frame_count}")


            if self.running_reward > 40:
                print("Solved at episode {}!".format(len(self.episode_reward_history)))
                break

            if len(self.episode_reward_history) >= 100000:
                print("Stopped at episode {}!".format(len(self.episode_reward_history)))
                break

env=make_env()
env.reset()
print (env.observation_space.shape)
agent = DQNAgent(env)
agent.train()

# run sessions

import gym.wrappers
import sys
from pathlib import Path
from base64 import b64encode
from IPython.display import HTML
env_test=make_env()
env_test.reset()
agent_test = DQNAgent(env_test)

n_games = 1

def evaluate1(env, agent_test, n_games=1, greedy=False, t_max=10000):
    """ Plays n_games full games. If greedy, picks actions as argmax(qvalues). Returns mean reward. """
    rewards = []
    q_values_history = []
    actions_history = []
    temp = QNetwork(4)
    temp.load_state_dict(torch.load("/content/drive/MyDrive/Colab/dql_model_target_32000"))
    temp.eval()
    for _ in range(n_games):
        s = env.reset()
        reward = 0
        q_values_episode = []
        actions_episode = []
        i=0
        for _ in range(t_max):
            state_tensor = torch.FloatTensor([s])
            qvalues = temp(state_tensor)
            q_values_episode.append(qvalues.detach().numpy())
            action = qvalues.argmax(axis=-1).item()
            actions_episode.append(action)
            s, r, done, _ = env.step(action)
            reward += r
            if done:
              env.reset()
              i+=1
            if i==5:
              break
        rewards.append(reward)
    return np.mean(rewards)

if type(os.environ.get("DISPLAY")) is not str or len(os.environ.get("DISPLAY")) == 0:
    !apt-get -qq install -y xvfb
    os.environ['DISPLAY'] = ':1'

display = Display(visible=0, size=(400, 300))
display.start()

with gym.wrappers.Monitor(make_env(), directory="videos", force=True) as env_monitor:
    env_monitor.reset()
    sessions = [evaluate1(env_monitor, agent, n_games=1, greedy=False) ]
video_paths = sorted([s for s in Path('videos').iterdir() if s.suffix == '.mp4'])
video_path = max(video_paths, key=os.path.getctime)
print
if 'google.colab' in sys.modules:
    # https://stackoverflow.com/a/57378660/1214547
    with video_path.open('rb') as fp:
        mp4 = fp.read()
    data_url = 'data:video/mp4;base64,' + b64encode(mp4).decode()
else:
    data_url = str(video_path)

HTML("""
<video width="640" height="480" controls>
  <source src="{}" type="video/mp4">
</video>
""".format(data_url))